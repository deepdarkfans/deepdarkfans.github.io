<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[概率论与数理统计（一）]]></title>
    <url>%2F%E6%95%B0%E5%AD%A6%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言专硕的痛苦，考研没考概率，上数学课 随机过程根本听不懂。于是又把考研的概率给看了一遍，临时做了笔记，现在整理成文章。 随机事件与概率本篇是笼统的介绍了一下概率论的内容，也是最简单的。此节分为三个部分： 古典概型 几何概型 重要公式 下面来一个个讲解。 古典概型定义：若样本空间有有限个样本点，成为古典概型（要求所有样本的发生概率相同）公式为： P(A)={A中样本数 \over 样本总数} 【注】：试验（E）所需条件 同等条件可重复 实验结果不止一个 实验前不知何种结果会出现 $\Omega \to 样本空间$ 古典概型有以下几种经典问题： 随机分配（占位） 如n个球中放N个盒子中，求概率。 简单随机抽样 袋子中有五个球，三白二黑，有放回和无放回抽取等。 几何概型（重点）定义：若$\Omega$是一个可度量的几何区域，那么样本点落入子区域A的概率与子区域A的度量成正比，与A的位置，形状无关。公式为： P(A)={A的度量 \over \Omega 的度量}【例子】：随机取两正数x，y，这两正数中有一个不超过1，求$x+y&lt;1$和$xy&lt;0.09$的概率。 【分析】：画出$x+y=1$和$xy=0.09$的函数图像之后用积分算出面积再比上总面积即可，算式如下： {\int_{0.1}^{0.9}1-x-{0.09 \over x}dx \over 1 } \approx 0.2重要公式求概率这里举出了很很多概率公式的四则运算以及化简. 对立事件公式 P(A)=1-P(\overline{A}) 加法公式 (1) $P(A+B)={P(A)+P(B)-P(AB)}$ (2) $P(A+B+C)={P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)} $ 【注】：若$A_1,A_2….A_n$两两互斥（即有$A_jA_i=\varnothing$）,则有$P(A_1+…A_n)={\sum_{i=1}^nP(A_i)}$ 事件互相独立，则有 P(A_{i1}A{i2}....A{in})={P(A_{i1})P(A_{i2})....P(A_{in})} 减法公式 P(A\overline{B})=P(A-B)=P(A)-P(AB) 独立公式 若事件A,B相互独立，则有 \overline{A},\overline{B}独立 \overline{A},B独立 A,\overline{B}独立于是，若$A_1,A_2….A_n$相互独立，则有 1-\prod_{i=1}^n(1-P(\overline{A_i})) 条件概率（除法） P(A|B)={P(AB) \over P(B)},P(B)>0其中$P(A|B)$指在B事件发生下A事件发生的概率 扩展: P(A_1A_2A_3)={P(A_1)P(A_2|A_1)P(A_3|A_2A_1)} 全概率公式 【引例】一个村子有三个小偷$A_1,A_2,A_3$，求事件$B=\{村子失窃\}$的概率 【分析】若$A\cup B\cup C=\Omega$,且$AB,AC,BC=\varnothing$,则称事件ABC为完备事件组，显然题中的三个为完备事件组。则有以下全概率公式; \begin{equation}\begin{split} P(B)&=P(BA_1 \cup BA_2 \cup BA_3)\\ &=P(BA_1)+P(BA_2)+P(BA_3)\\ &=P(B|A_1)P(A_1)+P(B|A_2)P(A_2)+P(B|A_3)P(A_3) \end{split}\end{equation}故有 P(B)=\sum_{i=1}^n{P(A_i)P(B|A_i)} 贝叶斯公式（逆概率公式） 定义：若B已经发生，求在B发生状态下是$A_i$干的的概率，执果索因。如上例中，若村子已经失窃，求是哪个小偷干的概率。公式为： P(A_i|B)={P(A_i|B) \over P(B)}\\ ={P(A_i)P(B|A_i) \over {\sum_{i=1}^n{P(A_i)P(B|A_i)}}} 一维随机分布随机变量以及分布函数定义：随机变量就是定义在样本空间$\Omega$上，取值在实数轴上的变量$\omega_i$。 分布函数定义：$F(x) := P\{X \le x\}$,其中$-\infty&lt;x&lt;+\infty$ x的定义可表示为随机变量在一维数轴上的所有集合，如当$x\to -\infty$时，随机变量X中没有比x小的，则为空集：$X(\omega_i)=\varnothing$,当$x\to +\infty$时，随机变量X中的所有可能都被x包含在内，则有$X(\omega_i)=\Omega$. 离散型随机变量定义：X取有限个或者无穷的可列的个体。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学概论]]></title>
    <url>%2F%E5%AF%86%E7%A0%81%E5%AD%A6%2F2019-10-06-%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[前言最近要讲密码学，只能从操旧业，把几年前已经扔掉的密码学在捡起来。买了本密码学原理与实践，在csdn上看了几篇博客，开始。老长时间没更新了，毕竟没人看，百度也不收录，没动力。 密码学（Cryptography）简介密码学已经有了几千年的历史，一般来说，特指1949年以后的为现代密码学，之前的有近代密码学和古典密码学之分，这两种基本上很好理解，都是字符的移位或者整一个替换表，一个一个加密和解密，密码学的真正发展实在与数学以及计算机结合起来之后而建立的一个有着数学基础作为支撑的一门学科。其中属对称加密最为经典，而之后发明的公钥加密（也就是非对称加密），也完善了对称加密的不足和弥补了对称加密的空白。这里我们简要概述一下对称和非对称，其他先不作为重点。 对称加密对称加密，即加密密钥和解密密钥相同，代表加密方式为数据加密标准（DES） 以及高级加密标准（AES） ，其中DES已经在AES加密标准生效之后废弃不用，以为安全性（密钥长度太短）得不到保障。而AES到目前为止依然是使用最多的对程加密，本文主要解释AES加密。 非对称加密（公钥加密）非对称加密在近代才被发明，代表有RSA加密等，此加密方式主要分为公钥加密和私钥解密（或者两者可互换）。这个加密的好处就是公钥是可以明文传输的，在传输过程中即使被人拦截，他也因为没有私钥而破解不了密文。而私钥是发送方和接收方各持有一个，因此不需要传输，保证了安全性。以下是一个例子 假设A与B要发送信息，A和B都互相持有各自的公钥。A可以用B的公钥加密明文，再将密文传输过去，然后B收到这个密文之后用自己的私钥来解密。 RSA不仅用于在通讯方面，在数字签名或者远程连接方面也很大应用。 AES加密详解 以下内容选自cn博客 我们知道数据加密标准（Data Encryption Standard: DES）的密钥长度是56比特，因此算法的理论安全强度是256。但二十世纪中后期正是计算机飞速发展的阶段，元器件制造工艺的进步使得计算机的处理能力越来越强，DES将不能提供足够的安全性。1997年1月2号，美国国家标准技术研究所（National Institute of Standards and Technology: NIST）宣布希望征集高级加密标准（Advanced Encryption Standard: AES）[3]，用以取代DES。AES得到了全世界很多密码工作者的响应，先后有很多人提交了自己设计的算法。最终有5个候选算法进入最后一轮：Rijndael，Serpent，Twofish，RC6和MARS，下图分别为其中的5位作者。最终经过安全性分析、软硬件性能评估等严格的步骤，Rijndael算法获胜。Rijndael由比利时两位非常著名的密码学家Joan Daemen和Vincent Rijmen设计。Rijndael是一个分组密码算法族，其分组长度包括128比特、160比特、192比特、224比特、256比特，密钥长度也包括这五种长度，但是最终AES只选取了分组长度为128比特，密钥长度为128比特、192比特和256比特的三个版本。本文主要结合AES-128进行介绍，AES-196和AES-256的思路基本一样，只是密钥扩展算法的过程会稍有不同，加解密的轮数会适当增加，但加解密的操作都是一样的。另外，本文只对AES算法的各个模块、基本原理进行介绍，旨在加深对算法流程、密码算法实现的了解。在正式软件运用中并不推荐自己编写代码，很多开源项目如Linux，OPENSSL，SRTP等都有非常高效的实现。由于数学知识的缺陷，本文不介绍算法安全性分析相关的知识，有兴趣的读者可以自行阅读相关文献。 AES是一个分组密码，属于对称密码范畴，AES算法的模块在对称密码领域特别是分组密码领域常有使用。 1. 算法流程AES加密算法涉及4种操作：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。下图给出了AES加解密的流程，从图中可以看出：1）解密算法的每一步分别对应加密算法的逆操作，2）加解密所有操作的顺序正好是相反的。正是由于这几点（再加上加密算法与解密算法每步的操作互逆）保证了算法的正确性。加解密中每轮的密钥分别由种子密钥经过密钥扩展算法得到。算法中16字节的明文、密文和轮子密钥都以一个4x4的矩阵表示。 字节替代字节代替的主要功能是通过S盒完成一个字节到另外一个字节的映射。S盒的详细构造方法可以《密码编码学与网络安全—原理和实践》。一下都按照《密码编码学与网络安全—原理和实践》教材里边的三个步骤进行推导。 步骤1、3都比较浅显，即使没有数论和有限域概念，一样可以编程写出来。 步骤一： 根据行标号和列标号组合成16X16的二维数组，行标号作为高4bit，列标号作为低4bit;本文重点叙述步骤2的推导。 步骤二： 这里边有三个概念：有限域、GF(2^8)、逆。 有限域：我的理解是，有一些元素构成了一个集合，集合中的一个或多个元素，进行某种运算，所得的结果仍然是集合中的元素。 元素，可以是具体的数字，也可以是字母，或是表达式，等等；某种运算，可以是加减乘除，或者逻辑运算，或者求余，或者是这几种运算的组合，等等。 这个定义当然很不严格，但是我觉得对于理解这个S盒推导够用了。 GF(2^8)：GF()是代表一个有限域，2^8=256，是指这个有限域内的元素的个数，即256个。 举个是有限域的集合的例子吧。 GF(7)={0，1，2，3，4，5，6}，它是关于任意两个元素的相加/乘积模7运算的有限域。特点是任意两个元素相加/乘积，对7取余数，这个余数仍然在GF(7)内。 截取《密码编码学与网络安全—原理和实践》中的例子：此外，这个$GF(7)$的7叫做阶，特点是阶与域内的元素都互素（互质）。 在计算机中，一个字节是8位，0~255刚好是一个字节所能代表的所有数字，但是呢，$GF(256)$，256对于0~255内的元素并不是每个都互素（互质），当以251为模时，251~255又不能用，造成浪费，所以不能直接使用上边的计算形式。但是我们还得必须用0~255这256个整数作为一个集合，通过某种运算构成有限域，所有只能把研究重点放在“某种运算”上。可能是为了区分$GF(256)$，所以用$GF(2^8)$。 逆：乘法逆元。定义：$GF(p)$， $(a)$、$(b)$、$(a-1)$都在$GF(p)$内，其中$(a)$、$(a-1)$互为乘法逆元，则有：$[(a) * (a-1)] mod (p) = 1$； 第二个步骤，就是 在步骤一得到的数组基础上，对每个元素 在 $GF(2^8)$有限域上求解出乘法逆元，在原位置替换该元素。 如何求解有限域上的逆元？《密码编码学与网络安全—原理和实践》中从欧几里得算法开始做知识铺垫，到扩展欧几里得算法。d=gcd(a,b)，d是a和b的最大公约数，或者叫最大公因子。求解步骤： 1、定义变量：$r0, r1, r2$ 2、赋初值$r0=a;r1=b;$ 3、求解$r0、r1$的余数：$(r3)=(r0) Mod (r1)$; 4、更新变量：$r0=r1;r1=r2;$ 5、从3开始重复，一直到求解的余数$r1$是0结束。 6、$r0$就是要求解的最大公约数。扩展欧几里得算法在书上的描写如下下面就是俩个构造好的S盒和逆S盒 行移位 行移位是一个4x4的矩阵内部字节之间的置换，用于提供算法的扩散性。 1) 正向行移位 正向行移位用于加密，其原理图如下。其中：第一行保持不变，第二行循环左移8比特，第三行循环左移16比特，第四行循环左移24比特。 假设矩阵的名字为state，用公式表示如下：$state’[i][j] = state[i][(j+i)%4];$其中$i、j$属于$[0,3]$。 2) 逆向行移位 逆向行移位即是相反的操作，即：第一行保持不变，第二行循环右移8比特，第三行循环右移16比特，第四行循环右移24比特。 用公式表示如下：$state’[i][j] = state[i][(4+j-i)%4];$其中$i、j$属于$[0,3]$。 列混淆列混淆：利用GF(28)域上算术特性的一个代替，同样用于提供算法的扩散性。 1) 正向列混淆 正向列混淆的原理图如下： 根据矩阵的乘法可知，在列混淆的过程中，每个字节对应的值只与该列的4个值有关系。此处的乘法和加法都是定义在GF(28)上的，需要注意如下几点： 1) 将某个字节所对应的值乘以2，其结果就是将该值的二进制位左移一位，如果原始值的最高位为1，则还需要将移位后的结果异或00011011 英文原文描述如下：In particular, multiplication of a value by x (i.e., by {02}) can be implemented as a 1-bit left shift followed by a conditional bitwise XOR with (0001 1011) if the leftmost bit of the original value (prior to the shift) is 1. 2) 乘法对加法满足分配率，例如：$07·S_{0,0}=(01⊕02⊕04)·S_{0,0}= S_{0,0}⊕(02·S_{0,0})(04·S_{0,0})$ 3) 此处的矩阵乘法与一般意义上矩阵的乘法有所不同，各个值在相加时使用的是模28加法（异或运算）。下面举一个例子，假设某一列的值如下图，运算过程如下： 在计算$02与C9$的乘积时，由于$C9$对应最左边的比特为1，因此需要将C9左移一位后的值与$(0001 1011)$求异或。同理可以求出另外几个值。 2) 逆向列混淆 逆向列混淆的原理图如下：因为：说明两个矩阵互逆，经过一次逆向列混淆后即可恢复原文。 轮密钥加这个操作相对简单，其依据的原理是“任何数和自身的异或结果为0”。加密过程中，每轮的输入与轮子密钥异或一次；因此，解密时再异或上该轮的轮子密钥即可恢复。 密钥拓展算法密钥扩展过程说明： 1) 将种子密钥按图(a)的格式排列，其中$k0、k1、……、k15$依次表示种子密钥的一个字节；排列后用4个32比特的字表示，分别记为$w[0]、w[1]、w[2]、w[3]$； 2) 按照如下方式，依次求解$w[j]$，其中j是整数并且属于$[4,43]$； 3) 若$j%4=0$,则$w[j]=w[j-4]⊕g(w[j-1])$,否则$w[j]=w[j-4]⊕w[j-1]$； 函数$g$的流程说明： a) 将w循环左移8比特； b) 分别对每个字节做S盒置换； c) 与32比特的常量$（RC[j/4],0,0,0）$进行异或，$RC$是一个一维数组，其值如下。（$RC$的值只需要有10个，而此处用了11个，实际上$RC[0]$在运算中没有用到，增加$RC[0]$是为了便于程序中用数组表示。由于$j$的最小取值是4，$j \over 4$的最小取值则是1，因此不会产生错误。） $RC$ = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36} 小结密码算法要求是可逆的，这样解密算法才能正确的恢复明文。拿AES来说，在密钥固定的情况下，明文和密文在整个输入空间是一一对应的。因此算法的各个部件也都是可逆的，再将各个部件的操作顺序设计成可逆的，密文就能正确的解密了。 源码自己找了一份C++的源码，准备作为演示,此代码在dev上编译成功：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;pbt.h&gt;#include &lt;ctype.h&gt;#include &lt;tchar.h&gt;#include &lt;windows.h&gt;using namespace std;void aes_detail(int[4][4], int[4][4], int);void subBytes(int [4][4], int);void shiftRows(int [4][4], int);void mixColumns(int [4][4], int);void addRoundKey(int [4][4], int[4][4]);int aes_multiple(int, int);void keyExpansion(int key[4][4], int w[11][4][4]);int c2i(char );int menu();int findfirstfile_lock();int findfirstfile_unlock();//S盒static const int S_BOX[16][16] = &#123; 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 &#125;;//逆S盒static const int INVERSE_S_BOX[16][16] = &#123; 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d &#125;;int RC[10] = &#123;0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36&#125;;void aes_detail(int content[4][4], int password[4][4], int encode)&#123; //aes主过程 int p[11][4][4]; keyExpansion(password, p); if (encode) &#123; addRoundKey(content, p[0]); for (int i = 1; i &lt;= 10; ++i) &#123; subBytes(content, encode); shiftRows(content, encode); if (i != 10) &#123; mixColumns(content, encode); &#125; addRoundKey(content, p[i]); &#125; &#125;else &#123; addRoundKey(content, p[10]); for (int i = 9; i &gt;= 0; --i) &#123; shiftRows(content, encode); subBytes(content, encode); addRoundKey(content, p[i]); if (i != 0) &#123; mixColumns(content, encode); &#125; &#125; &#125;&#125;void subBytes(int a[4][4], int encode)&#123; //字节替换 for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; int temp = a[i][j]; int row = temp / 16; int column = temp % 16; if (encode) a[i][j] = S_BOX[row][column]; else a[i][j] = INVERSE_S_BOX[row][column]; &#125; &#125;&#125;void shiftRows(int a[4][4], int encode)&#123; //行变换 for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (encode) &#123; int temp = a[i][0]; a[i][0] = a[i][1]; a[i][1] = a[i][2]; a[i][2] = a[i][3]; a[i][3] = temp; &#125; else&#123; int temp = a[i][3]; a[i][3] = a[i][2]; a[i][2] = a[i][1]; a[i][1] = a[i][0]; a[i][0] = temp; &#125; &#125; &#125;&#125;void mixColumns(int a[4][4], int encode)&#123; //列混淆 for (int i = 0; i &lt; 4; ++i) &#123; int temp0 = a[0][i]; int temp1 = a[1][i]; int temp2 = a[2][i]; int temp3 = a[3][i]; if (encode) &#123; a[0][i] = aes_multiple(temp0, 2) ^ aes_multiple(temp1, 3) ^ temp2 ^ temp3; a[1][i] = temp0 ^ (aes_multiple(temp1, 2)) ^ (temp2 ^ aes_multiple(temp2, 2)) ^ temp3; a[2][i] = temp0 ^ temp1 ^ (aes_multiple(temp2, 2)) ^ (temp3 ^ aes_multiple(temp3, 2)); a[3][i] = temp0 ^ (aes_multiple(temp0, 2)) ^ temp1 ^ temp2 ^ aes_multiple(temp3, 2); &#125;else&#123; a[0][i] = aes_multiple(temp0, 14) ^ aes_multiple(temp1, 11) ^ aes_multiple(temp2, 13) ^ aes_multiple(temp3, 9); a[1][i] = aes_multiple(temp0, 9) ^ aes_multiple(temp1, 14) ^ aes_multiple(temp2, 11) ^ aes_multiple(temp3, 13); a[2][i] = aes_multiple(temp0, 13) ^ aes_multiple(temp1, 9) ^ aes_multiple(temp2, 14) ^ aes_multiple(temp3, 11); a[3][i] = aes_multiple(temp0, 11) ^ aes_multiple(temp1, 13) ^ aes_multiple(temp2, 9) ^ aes_multiple(temp3, 14); &#125; &#125;&#125;void addRoundKey(int a[4][4], int k[4][4])&#123; //轮密钥加 for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; a[i][j] = a[i][j] ^ k[j][i]; &#125; &#125;&#125;int aes_multiple(int a, int le)&#123; //列混淆 int thr = le &amp; 0x8; int sec = le &amp; 0x4; int fir = le &amp; 0x2; int fir_mod = le % 2; int result = 0; if (thr)&#123; int b = a; for (int i = 1; i &lt;=3 ; ++i) &#123; b = b&lt;&lt;1; if (b &gt;= 256) b = b ^ 0x11b; &#125; b = b % 256; result = result ^ b; &#125; if (sec)&#123; int b = a; for (int i = 1; i &lt;=2 ; ++i) &#123; b = b&lt;&lt;1; if (b &gt;= 256) b = b ^ 0x11b; &#125; b = b % 256; result = result ^ b; &#125; if (fir)&#123; int b = a &lt;&lt; 1; if (b &gt;= 256) b = b ^ 0x11b;//按位异或 b = b % 256;//求mod result = result ^ b;//异或 &#125; if (fir_mod) result = result ^ a; return result;&#125;void keyExpansion(int key[4][4], int w[11][4][4])&#123; //扩展密钥 for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; w[0][i][j] = key[j][i]; &#125; &#125; for (int i = 1; i &lt; 11; ++i)&#123; for (int j = 0; j &lt; 4; ++j) &#123; int temp[4]; if (j == 0)&#123; temp[0] = w[i-1][3][1]; temp[1] = w[i-1][3][2]; temp[2] = w[i-1][3][3]; temp[3] = w[i-1][3][0]; for (int k = 0; k &lt; 4; ++k) &#123; int m = temp[k]; int row = m / 16; int column = m % 16; temp[k] = S_BOX[row][column]; if (k == 0)&#123; temp[k] = temp[k] ^ RC[i-1]; &#125; &#125; &#125; else&#123; temp[0] = w[i][j-1][0]; temp[1] = w[i][j-1][1]; temp[2] = w[i][j-1][2]; temp[3] = w[i][j-1][3]; &#125; for (int l = 0; l &lt; 4; ++l) &#123; w[i][j][l] = w[i-1][j][l] ^ temp[l]; &#125; &#125; &#125;&#125;int c2i(char ch) &#123; if(isdigit(ch)) return ch - 48; if( ch &lt; &apos;A&apos; || (ch &gt; &apos;F&apos; &amp;&amp; ch &lt; &apos;a&apos;) || ch &gt; &apos;z&apos; ) return -1; if(isalpha(ch)) return isupper(ch) ? ch - 55 : ch - 87; return -1;&#125;int findfirstfile_lock() //批量加密 &#123; WIN32_FIND_DATA FindFileData; HANDLE hFind; hFind = FindFirstFile(&quot;E:\\待加密\\*.txt&quot;, &amp;FindFileData); if (hFind == INVALID_HANDLE_VALUE) &#123; printf (&quot;FindFirstFile failed (%d)\n&quot;, GetLastError()); return -2; &#125; do &#123; int method = 1; char x[50]; char y[50]; char z[50]; char source_path[50]; char des_path[50]; strcpy(x,&quot;E:\\\\待加密\\\\&quot;); strcpy(y,&quot;E:\\\\已加密\\\\&quot;); strcpy(source_path,FindFileData.cFileName); strcpy(des_path,FindFileData.cFileName); strcat(x,source_path); strcat(y,des_path); const char * password = &quot;0f1571c947d9e8590cb7add6af7f6798&quot;; int p[4][4]; for (int m = 0; m &lt; 4; ++m) &#123; for (int i = 0; i &lt; 4; ++i) &#123; int indx = 4 * i + m; p[i][m] = 16 * c2i(password[indx]) + c2i(password[indx + 1]); &#125; &#125; FILE *file = fopen(x, &quot;r&quot;); fseek(file, 0, SEEK_END); int len = ftell(file); rewind(file); int size = len; if (len % 16 != 0) &#123; size = (len / 16 + 1) * 16; &#125; unsigned char content[size]; fread(content, 1, len, file); for (int j = len; j &lt; size; ++j) &#123; content[j] = 0; &#125; fclose(file); unsigned char encry[size]; for (int i = 0; i &lt; size / 16; ++i) &#123; int content_to_int[4][4]; for (int j = 0; j &lt; 4; ++j) &#123; for (int k = 0; k &lt; 4; ++k) &#123; content_to_int[j][k] = content[j * 4 + k + 16 * i]; &#125; &#125; aes_detail(content_to_int, p, method); for (int j = 0; j &lt; 4; ++j) &#123; for (int k = 0; k &lt; 4; ++k) &#123; encry[j * 4 + k + 16 * i] = content_to_int[j][k]; &#125; &#125; &#125; FILE *file1 = fopen(y, &quot;w&quot;); fwrite(encry, size, 1, file1); fflush(file1); fclose(file1); &#125; while (FindNextFile(hFind, &amp;FindFileData)); return 0;&#125;int findfirstfile_unlock()//批量解密 &#123; WIN32_FIND_DATA FindFileData; HANDLE hFind; hFind = FindFirstFile(&quot;E:\\已加密\\*.txt&quot;, &amp;FindFileData); if (hFind == INVALID_HANDLE_VALUE) &#123; printf (&quot;FindFirstFile failed (%d)\n&quot;, GetLastError()); return -2; &#125; do &#123; int method = 0; char x[50]; char y[50]; char source_path[50]; char des_path[50]; strcpy(x,&quot;E:\\\\已加密\\\\&quot;); strcpy(y,&quot;E:\\\\已解密\\\\&quot;); strcpy(source_path,FindFileData.cFileName); strcpy(des_path,FindFileData.cFileName); strcat(x,source_path); strcat(y,des_path); const char * password = &quot;0f1571c947d9e8590cb7add6af7f6798&quot;; int p[4][4]; for (int m = 0; m &lt; 4; ++m) &#123; for (int i = 0; i &lt; 4; ++i) &#123; int indx = 4 * i + m; p[i][m] = 16 * c2i(password[indx]) + c2i(password[indx + 1]); &#125; &#125; FILE *file = fopen(x, &quot;r&quot;); fseek(file, 0, SEEK_END); int len = ftell(file); rewind(file); int size = len; if (len % 16 != 0) &#123; size = (len / 16 + 1) * 16; &#125; unsigned char content[size]; fread(content, 1, len, file); for (int j = len; j &lt; size; ++j) &#123; content[j] = 0; &#125; fclose(file); unsigned char encry[size]; for (int i = 0; i &lt; size / 16; ++i) &#123; int content_to_int[4][4]; for (int j = 0; j &lt; 4; ++j) &#123; for (int k = 0; k &lt; 4; ++k) &#123; content_to_int[j][k] = content[j * 4 + k + 16 * i]; &#125; &#125; aes_detail(content_to_int, p, method); for (int j = 0; j &lt; 4; ++j) &#123; for (int k = 0; k &lt; 4; ++k) &#123; encry[j * 4 + k + 16 * i] = content_to_int[j][k]; &#125; &#125; &#125; FILE *file1 = fopen(y, &quot;w&quot;); fwrite(encry, size, 1, file1); fflush(file1); fclose(file1); &#125; while (FindNextFile(hFind, &amp;FindFileData)); return 0;&#125;int menu()&#123; int i; system(&quot;cls&quot;); cout&lt;&lt;&quot;AES文件加密系统&quot;&lt;&lt;endl; cout&lt;&lt;&quot; 1、加密&quot;&lt;&lt;endl; cout&lt;&lt;&quot; 2、解密&quot;&lt;&lt;endl; cout&lt;&lt;&quot; 0、退出&quot;&lt;&lt;endl; cin&gt;&gt;i;// while(!(i&gt;=0&amp;&amp;i&lt;=2))// cin&gt;&gt;i; return i;&#125;int main()&#123; //主程序 re: int i = 0; system(&quot;cls&quot;); i=menu(); &#123; if(i == 1) &#123; findfirstfile_lock(); cout&lt;&lt;&quot;加密完成&quot;&lt;&lt;endl; system(&quot;pause&quot;); &#125; else if(i == 2) &#123; findfirstfile_unlock(); cout&lt;&lt;&quot;解密完成&quot;&lt;&lt;endl; system(&quot;pause&quot;); &#125; else &#123; cout&lt;&lt;&quot;已退出&quot;&lt;&lt;endl; exit(0); &#125; &#125; goto re; return 0;&#125; 待更新。。。]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python机器学习（四）]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FPython%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言：之前看的python machine learning Case Studies 的讲解不是很系统，更换了参考书，名字是machine learning in action。第一章就讲了机器学习最基本的knn算法 kNN算法简介kNN，全称为k-Nearest Neighbors，其计算与线性回归相关，其中的K表示最接近自己的K个数据样本。KNN算法和K-Means算法不同的是，K-Means算法用来聚类，用来判断哪些东西是一个比较相近的类型，而KNN算法是用来做归类的，也就是说，有一个样本空间里的样本分成很几个类型，然后，给定一个待分类的数据，通过计算接近自己最近的K个样本来判断这个待分类数据属于哪个分类。你可以简单的理解为由那离自己最近的K个点来投票决定待分类数据归为哪一类。 下面是kNN算法的优势和缺陷： k-Nearest Neighbors Pros: High accuracy, insensitive to outliers, no assumptions about data Cons: Computationally expensive, requires a lot of memory Works with: Numeric values, nominal values 由以上原文可知，knn优点是高效，不受离群值影响，不用假设数据。缺点是计算麻烦，需要大量的内存。 原文kNN算法步骤如下; Collect: Any method. Prepare: Numeric values are needed for a distance calculation. A structured data format is best. Analyze: Any method. Train: Does not apply to the kNN algorithm. Test: Calculate the error rate. Use: This application needs to get some input data and output structured numeric values. Next, the application runs the kNN algorithm on this input data anddetermines which class the input data should belong to. The application then takes some action on the calculated class. 下面一一开始步骤 Collect原文例子： Let’s run through a quick example classifying movies into romance or action movies. Someone watched a lot of movies and counted the number of kicks and kisses ineach movie. I’ve plotted six movies by the number of kisses and kicks in each movie infigure 2.1. Now, you find a movie you haven’t seen yet and want to know if it’s aromance movie or an action movie. To determine this, we’ll use the kNN algorithm 根据亲嘴次数和打架次数来让机器分别爱情片和动作片。。。下面是片子的例子 片名 打架次数 亲吻次数 电影类型 California Man 3 104 爱情片 Kevin Longblade 101 10 动作片 ？ 18 90 未知 我们可以画一个平面直角坐标系，两种次数做$x$和$y$轴,电影就是一个一个点坐标。 Prepare用python输入数据，先建立个py文件，再用命令行导入此文件 代码如下：12345678import numpy as npimport operator #排列数据def createDataSet(): #四组二维特征 group = np.array([[1,101],[5,89],[108,5],[115,8]]) #四组特征的标签 labels = [&apos;爱情片&apos;,&apos;爱情片&apos;,&apos;动作片&apos;,&apos;动作片&apos;] return group, labels 原文解释： In this code, we import two modules. The first one is NumPy, which is our scientificcomputing package. The second module is the operator module, which is used laterin the kNN algorithm for sorting; we’ll get to that shortly.The function createDataSet() is there for your convenience. This creates thedataset and labels, as shown in figure 2.1. Let’s try this out: save kNN.py, change to thedirectory where you’ve stored kNN.py, and launch a Python interactive session. To getstarted you need to open a new terminal in Linux/Mac OS or in Windows, so open acommand prompt. When you’re using Linux or a Mac, you need to type python at thecommand line to get started, and in Windows you need to refer to the Python program directly, such as c:\Python26\python.exe, unless you have it aliased. 接着我们用Python命令行导入此文件 1&gt;&gt;&gt; import kNN 给group和labels赋值1&gt;&gt;&gt; group,labels=kNN.creatrDataSet() 打印一下验证123456groupOut[6]: array([[ 1, 101], [ 5, 89], [108, 5], [115, 8]]) Putting the kNN classification algorithm into action这一节将编写一个函数，来实现knn算法，算法步骤应该像这样： For every point in our dataset: calculate the distance between inX and the current point sort the distances in increasing order take k items with lowest distances to inX find the majority class among these items return the majority class as our prediction for the class of inX Python实现代码如下：12345678910111213141516171819202122232425262728def classify0(inX, dataSet, labels, k): #numpy函数shape[0]返回dataSet的行数 dataSetSize = dataSet.shape[0] #在列向量方向上重复inX共1次(横向)，行向量方向上重复inX共dataSetSize次(纵向) diffMat = np.tile(inX, (dataSetSize, 1)) - dataSet #二维特征相减后平方 sqDiffMat = diffMat**2 #sum()所有元素相加，sum(0)列相加，sum(1)行相加 sqDistances = sqDiffMat.sum(axis=1) #开方，计算出距离 distances = sqDistances**0.5 #返回distances中元素从小到大排序后的索引值 sortedDistIndices = distances.argsort() #定一个记录类别次数的字典 classCount = &#123;&#125; for i in range(k): #取出前k个元素的类别 voteIlabel = labels[sortedDistIndices[i]] #dict.get(key,default=None),字典的get()方法,返回指定键的值,如果值不在字典中返回默认值。 #计算类别次数 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 #python3中用items()替换python2中的iteritems() #key=operator.itemgetter(1)根据字典的值进行排序 #key=operator.itemgetter(0)根据字典的键进行排序 #reverse降序排序字典 sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True) #返回次数最多的类别,即所要分类的类别 return sortedClassCount[0][0] 这里面主要用到了初中学的两点之间距离公式 d=\sqrt{(xA_0-xB_0)^2+(xA_1-xB_1)^2}Testing设inX为（0,1），k值设为3，返回值为12kNN.classify0((0,1),group,labels,3)Out[5]: &apos;爱情片&apos; 后记这个例子在这个部分的确起了作用，但是仍然解决不了现实世界的问题，下一节学习knn算法现实生活的运用。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python机器学习（二）]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FPython%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言因为多变量分析内容太多，而且涉及很多的统计学基础（绝大部分高中都学过），所以这一章算是复习，分两篇来写。 数据分析之多变量分析Multivariate Analysis（多变量分析）多变量分析的意义就是研究多种自变量而得到因变量的表现。这看起来比单变量分析更加的真实和可靠，毕竟在现实生活中，各个事物都是互相联系的。 按生日和性别分析南希认为同一时期的男性用户使用频率要远大于女性用户。因为根据之前的表图，男性用户使用总次数要远多于女性。艾瑞克认为研究这个方面的最好的办法就是绘制一个堆叠柱状图（stacked bar graph）（柱状图中每一个柱都有两种以上的颜色，这里颜色代表性别）代码如下： 123groupby_birthyear_gender = data.groupby([&apos;birthyear&apos;, &apos;gender&apos;])[&apos;birthyear&apos;].count().unstack(&apos;gender&apos;).fillna(0)#以出生年月和性别排序，并将性别的索引由列改为行groupby_birthyear_gender[[&apos;Male&apos;,&apos;Female&apos;,&apos;Other&apos;]].plot.bar(title = &apos;Distribution of birth years by Gender&apos;, stacked=True, figsize = (15,4))plt.show() Output： 代码含义：我们先将数据帧的列索引用unstack函数给转换为行索引，之后，将gender这一个列给分为三种：男，女，其他。这样我们就有了三种性别的不同的行程总数。 由图可知男士的确占大多数，但是也有例外。比如1947年出生的人使用单车的全为女性。1964和1994的人也大多是女性。 按生日和用户类型分析在之前对80后用户的分析来看，所有的用户都是会员。南希非常好奇其他的年龄段的会员占比是多少？难道大多数都是普通用户？于是艾瑞克开始对生日和用户类型进行分析：123groupby_birthyear_usertype=data.groupby([&apos;birthyear&apos;,&apos;usertype&apos;])[&apos;birthyear&apos;].count().unstack(&apos;usertype&apos;).fillna(0)#以出生年月和用户类型排序，并将用户类型的索引由列改为行groupby_birthyear_usertype[&apos;Member&apos;].plot.bar(title=&apos;Distribution of birth years by Usertype&apos;,stacked=True,figsize=(15,4))plt.show() Output： 南希看了非常惊讶：咋全都是会员？难道只有正式会员才需要填写生日？艾瑞克决定验证一下1print(data[data[&apos;usertype&apos;]==&apos;Short-Term Pass Holder&apos;][&apos;birthyear&apos;].isnull().values.all())#验证普通会员是否有出生年月 Output：1True 果然，普通用户并没有填写生日。同样的，艾瑞克又验证了一下普通用户是否填写了性别，结果也是没有填写。说明我们没有任何关于普通用户的身份数据。南希不得不重新考虑之前的推断：关于80后的品牌忠诚度。因为根本不知道80后的会员在80后总人数占多少。这个数据废弃了南希之前的推断。 时间序列分析南希想知道基于开始日期的行程的频数。于是艾瑞克不得不把起始日期给转换为日期字符格式，他还做了更多，将日期拆分为多个小段（年，月，日，小时等）。 代码如下：12345678910List_=list(data[&apos;starttime&apos;])#把开始时间转换时间字符串List_=[datetime.datetime.strptime(x, &quot;%m/%d/%Y %H:%M&quot;) for x in List_]#将时间字符串转换为时间元组data[&apos;starttime_mod&apos;]=pd.Series(List_,index=data.index)#Series函数创建索引data[&apos;starttime_date&apos;] = pd.Series([x.date() for x in List_],index=data.index)data[&apos;starttime_year&apos;] = pd.Series([x.year for x in List_],index=data.index)data[&apos;starttime_month&apos;] = pd.Series([x.month for x in List_],index=data.index)data[&apos;starttime_day&apos;] = pd.Series([x.day for x in List_],index=data.index)data[&apos;starttime_hour&apos;] = pd.Series([x.hour for x in List_],index=data.index)data.groupby(&apos;starttime_date&apos;)[&apos;tripduration&apos;].mean().plot.bar(title = &apos;Distribution of Trip duration by date&apos;, figsize = (15,4))plt.show() Output： 这个表格看起来有一种显而易见的走势。这就引出了时间序列的一些定义。 Time Series Components下面是时间序列中最常见的三种走势图。 Seasonal Pattern（季节性走势）如图所示，季节性走势总是有着时间规律，这些时期可以是一月中的周数，一年中的周数，也可以是一年中的月数。 Cyclic Pattern（循环走势）循环走势唯一与季节性走势不同之处在于循环走势没有时间上的规律。 Trend（趋势）趋势就是一段宏观上来看上升或降低的连续变量。这种走势可能不是很精准的线性走势，but when smoothing is applied it can generalize into either of the direction.（这句话不会翻译，大概意思知道） 由这几个走势；来看，南希认为这个时间行程的走势明显是季节性走势。因为这个图的趋势总是有一段精确的时间间隔，这就是季节性。事实上，我们可以把分布给分为三种类型。一种是季节性，就是每隔一段时间就会重复。一种是水平密度分布（flat density distribution），第三种就是线性分布。 到这第二部分完毕]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python机器学习（四）]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FPython%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[kNN算法实例 本篇主要学到了kNN算法在实际生活中的运用，这里是实例之一：海伦约会 提出需求原文：My friend Hellen has been using some online dating sites to find different people togo out with. She realized that despite the site’s recommendations, she didn’t likeeveryone she was matched with. After some introspection, she realized there werethree types of people she went out with: People she didn’t like People she liked in small doses People she liked in large doses After discovering this, Hellen couldn’t figure out what made a person fit into any ofthese categories. They all were recommended to her by the dating site. The peoplewhom she liked in small doses were good to see Monday through Friday, but on theweekend she’d rather spend time with the people she liked in large doses. Hellen hasasked us to help her filter future matches to categorize them. In addition, Hellen hascollected some data that isn’t recorded by the dating site, but she feels it’s useful inselecting people to go out with. 实现步骤 原文： Collect: Text file provided. Prepare: Parse a text file in Python. Analyze: Use Matplotlib to make 2D plots of our data. Train: Doesn’t apply to the kNN algorithm. Test: Write a function to use some portion of the data Hellen gave us as test examples. The test examples are classified against the non-test examples. If thepredicted class doesn’t match the real class, we’ll count that as an error. Use: Build a simple command-line program Hellen can use to predict whethershe’ll like someone based on a few inputs. 准备海伦准备了一个txt格式数据集。一共有1000条信息]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python机器学习（三）]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FPython%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[中心极限定理部分转载自朱曦炽个人博客，假设检测部分转载维基百科等 假设检测及中心极限定理 Hypothesis Testing（假设检测）简介假设检验是推论统计中用于检验统计假设的一种方法。 而“统计假设”是可通过观察一组随机变量的模型进行检验的科学假说。[1]一旦能估计未知参数，就会希望根据结果对未知的真正参数值做出适当的推论。 统计上对参数的假设，就是对一个或多个参数的论述。而其中欲检验其正确性的为零假设（null hypothesis），零假设通常由研究者决定，反映研究者对未知参数的看法。相对于零假设的其他有关参数之论述是备择假设（alternative hypothesis），它通常反应了执行检定的研究者对参数可能数值的另一种（对立的）看法（换句话说，备择假设通常才是研究者最想知道的）。 假设检验的种类包括：t检验，Z检验，卡方检验，F检验等等。 说明假设检验的过程，可以用法庭的审理来说明。先想像现在法庭上有一名被告，假设该被告是清白的，而检察官必须要提出足够的证据去证明被告的确有罪。 在证明被告有罪前，被告是被假设为清白的。 假设被告清白的假设，就相当于零假设（null hypothesis）。 假设被告有罪的假设，则是备择假设（alternative hypothesis）。 而检察官提出的证据，是否足以确定该被告有罪，则要经过检验。 这样子的检验过程就相当于用T检验或Z检验去检视研究者所搜集到的统计资料。 过程在统计学的文献中，假设检验发挥了重要作用。假设检验大致有如下步骤： 最初研究假设为真相不明。 第一步是提出相关的零假设和对立假设。这是很重要的，因为错误陈述假设会导致后面的过程变得混乱。 第二步是考虑检验中对样本做出的统计假设；例如，关于独立性的假设或关于观测数据的分布的形式的假设。这个步骤也同样重要，因为无效的假设将意味着试验的结果是无效的。 决定哪个检测是合适的，并确定相关检验统计量 T。 在零假设下推导检验统计量的分布。在标准情况下应该会得出一个熟知的结果。比如检验统计量可能会符合学生t-分布或正态分布。 选择一个显著性水平 (α)，若低于这个概率阈值，就会拒绝零假设。最常用的是 5% 和 1%。 根据在零假设成立时的检验统计量T分布，找到数值最接近备择假设，且几率为显著性水平 (α)的区域，此区域称为“拒绝域”，意思是在零假设成立的前提下，落在拒绝域的几率只有α。 针对检验统计量T，根据样本计算其估计值tobs。 若估计值tobs未落在“拒绝域”，接受零假设。若估计值tobs落在“拒绝域”，拒绝零假设，接受对立假设。 例子淑女品茶是一个有关假设检验的著名例子[2]，费雪的一个女同事声称可以判断在奶茶中，是先加入茶还是先加入牛奶。费雪提议给她八杯奶茶，四杯先加茶，四杯先加牛奶，但随机排列，而女同事要说出这八杯奶茶中，哪些先加牛奶，哪些先加茶，检验统计量是确认正确的次数。零假设是女同事无法判断奶茶中的茶先加入还是牛奶先加入，对立假设为女同事有此能力。 若单纯以几率考虑（即女同事没有判断的能力）下，八杯都正确的几率为1/70，约1.4%，因此“拒绝域”为八杯的结果都正确。而测试结果为女同事八杯的结果都正确，在统计上是相当显著的的结果。 Central Limit Theorem（中心检测定理）简介 中心极限定理指的是给定一个任意分布的总体。我每次从这些总体中随机抽取 n 个抽样，一共抽 m 次。 然后把这 m 组抽样分别求出平均值。 这些平均值的分布接近正态分布。 举个例子 现在我们要统计全国的人的体重，看看我国平均体重是多少。当然，我们把全国所有人的体重都调查一遍是不现实的。所以我们打算一共调查1000组，每组50个人。 然后，我们求出第一组的体重平均值、第二组的体重平均值，一直到最后一组的体重平均值。中心极限定理说：这些平均值是呈现正态分布的。并且，随着组数的增加，效果会越好。 最后，当我们再把1000组算出来的平均值加起来取个平均值，这个平均值会接近全国平均体重。 其中要注意的几点： 总体本身的分布不要求正态分布上面的例子中，人的体重是正态分布的。但如果我们的例子是掷一个骰子（平均分布），最后每组的平均值也会组成一个正态分布。（神奇！） 样本每组要足够大，但也不需要太大取样本的时候，一般认为，每组大于等于30个，即可让中心极限定理发挥作用。 话不多说，我们现在来一步步看到中心极限定理是如何起作用的。 例子生成数据假设我们现在观测一个人掷骰子。这个骰子是公平的，也就是说掷出1~6的概率都是相同的：1/6。他掷了一万次。我们用python来模拟投掷的结果： 1234import numpy as np random_data = np.random.randint(1, 7, 10000)print random_data.mean() # 打印平均值print random_data.std() # 打印标准差 生成出来的平均值：3.4927 （每次重新生成都会略有不同）生成出来的标准差：1.7079 平均值接近3.5很好理解。 因为每次掷出来的结果是1、2、3、4、5、6。 每个结果的概率是1/6。所以加权平均值就是3.5。 画图我们把生成的数据用直方图画出来直观地感受一下： 抽一组样本我们接下来随便先拿一组抽样，手动算一下。例如我们先从生成的数据中随机抽取10个数字： 12345sample1 = []for i in range(0, 10): sample1.append(random_data[int(np.random.random() * len(random_data))]) print sample1 # 打印出来 这10个数字的结果是： [3, 4, 3, 6, 1, 6, 6, 3, 4, 4]平均值：4.0标准差：1.54 可以看到，我们只抽10个的时候，样本的平均值（4.0）会距离总体的平均值（3.5）有所偏差。有时候我们运气不好，抽出来的数字可能偏差很大，比如抽出来10个数字都是6。那平均值就是6了。 为什么会出现都是6的情况呢？因为我比较6…哦不是，因为这就是随机的魅力呀！ 验证定理我们让中心极限定理发挥作用。现在我们抽取1000组，每组50个。我们把每组的平均值都算出来。 1234567891011121314151617samples = []samples_mean = []samples_std = []for i in range(0, 1000): sample = [] for j in range(0, 50): sample.append(random_data[int(np.random.random() * len(random_data))]) sample_np = np.array(sample) samples_mean.append(sample_np.mean()) samples_std.append(sample_np.std()) samples.append(sample_np) samples_mean_np = np.array(samples_mean)samples_std_np = np.array(samples_std)print samples_mean_np 这一共1000个平均值大概是这样的：[3.44, 3.42, 3.22, 3.2, 2.94 … 4.08, 3.74] （我肯定不会把1000个数字都写完，又没有稿费可以骗） 然后，我们把这1000个数字用直方图画出来： TADA! 完美地形成了正态分布。 结果打印如下： 平均值：3.48494标准差：0.23506 尾声这两个统计学和概率论中的知识和概念在机器学习中有这重要的应用，但这些概念较为基础，需要牢牢把握。这两个概念我都是转载的博客，比较易于理解。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python机器学习（一）]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FPython%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原创前言还有三月就升学了，趁着没有什么事干（北京的实习也没去），先看看研究生的方向机器学习和数据分析。在网上找了几本参考资料，看到了一本英文书，叫《Python Machine Learning Case Studies》，里面有5个case studies，主要是用来学习数据分析和数据挖掘，书里用生动的例子讲解了机器学习在日常生活和企业中的应用 ，第一个研究是共享单车系统，刚看完第一部分，做个学习笔记。 数据分析之单变量分析Cycle Sharing Scheme该课程是由一个事例讲起的，有俩人想搞个共享单车系统，一个叫南希（Nancy），一个叫埃里克（Eric）。南希是市场调查，把握大方向，埃里克是个苦逼程序员，天天要打代码满足南希需求。有个叫杰森（Jason）的，共享单车弄发财了，于是南希让埃里克分析他这几年的共享单车用户，所以埃里克弄来了一个csv文件，里面都是杰森的用户记录。为了分析这些数据，埃里克用python装了上了很多第三方库，开始分析。这些库如下:123456789import randomimport datetimeimport statisticsimport pandas as pdimport matplotlib.pyplot as pltimport numpyimport scipyimport seabornfrom scipy import stats 不用多说，绝大部分都是学过大数据的人用过的库。 Performing Exploratory Data Analysis埃里克开始进行数据分析，首先要把csv文件给弄进内存里，于是埃里克用了data=pd.read_csv(&#39;trip.csv&#39;)命令将csv文件读入内存，并用print(len(data))命令显示出了数据长度如下图所示： 南希看到数据之后，她想把列表中的属性列给定义一下变量类型，以便进一步更好分析。这就引出了本章最最重要的重点：Types of variables。 Types of Variables此部分没有代码，全部是统计学基础理论知识，我也是第一次学，如有翻译或者解释错误的问题请原谅笔者智商不高。 Continuous/Quantitative Variables(连续变量)所谓连续变量，在这里只一个有着无限个数的序列(infinite number of values within a given range)。这个序列是不可数的。在学习连续变量之前，要先知道什么是基准零点（True zero point）。 True Zero Point（基准零点）如果一种衡量等级有基准零点，那么当为0的时候，那它就代表啥都没有，即为空。举个例子，有一个定比变量（ratio variables）代表着你买的蛋糕数量。如果这个变量为零，那么就意味着你一个蛋糕没买，为空。基准零点是定距尺度变量和定比变量之间最明显的区别。 Interval Variables（定距尺度变量）定距尺度变量，只在自然中连续而又是数字化的值（这句话可能我自己翻译有问题）。举个例子，房子中的温度。10摄氏度和20摄氏度的区别和30摄氏度和40摄氏度的区别是一样的，但是当温度为零时，并不代表温度不存在。所以定距尺度变量不存在基准零点。 Ratio Variables（定比变量）定比变量与定距尺度变量非常相似，唯一区别就在于定比变量存在基准零点。举个例子，一辆车走的距离，如果距离为0，则说明车一步没走，距离不存在。 Discrete Variables（离散变量）离散变量意义与连续变量相反，是指一个有限个值的序列。这个序列里的值是可数的。以下就是一些离散变量的分类。 Ordinal Variables （定序变量）顾名思义，定序变量就是一种可以由低到高或由高到低排列的变量，它不仅能够代表事物的分类，还能够代表事物按某种高低顺序排序。（These levels within ordinal variables can have unequal spacing between them）。举例说明 大学 高中 中学 小学 可以清楚看到，这四个是按照由高到低的序列排列的。但是，大学与高中的区别和中学与小学的区别并没有什么可比性。（与上面的温度的例子作比较），所以，定序变量一般是没有定距尺度（interval）的，所以定序变量做差是没有意义的。 Nominal Variables（定类变量）变量的不同仅仅表示了代表不同种类的事物。。比如性别，一年中的月份，工厂出场的不同的车等等。因而，定类变量做加减乘除运算都是无意义的。 Dichotomous Variables （二分变量）二分变量特指在定类变量中只有两个种类或水平的变量。举例说明： 年龄： 24岁，高于24岁。 性别： 男士，女士。 Lurking Variables（潜在变量）潜在变量既不是因变量也不是解释变量（自变量）。它的存在可能会影响这些变量之间联系的解释。比如我们基于一个应聘者的性别来预测他能否顺利入职，那么这个应聘者要应聘的部门就可能是一个潜在变量。 Demographic Variables（人口变量）不是重点，略微说一哈。就是研究人口的变量。 Dependent and Independent Variables（因变量和自变量）直接给个方程：$y=2x$，懂得都懂。 弄懂了这些变量之后，南希很容易的将各个属性都分了变量类别。但是即使她弄懂了这些变量的类别，她仍然对这一大段数据的信息提取束手无策。她告诉了艾瑞克。艾瑞克马上有了答案。这引出了又一个重点：Univariate Analysis（单变量分析）。 Univariate AnalysisUnivariate中的uni就代表一个的意思，单变量分析就是用一个变量来分析，而不考虑其他的因变量1如何变化。艾瑞克就准备用单变量分析来一个个研究这些数据的特性。 按使用的开始日期排序代码如下: 123data = data.sort_values(by=&apos;starttime&apos;)#开始时间排序数据data.reset_index()#还原索引，变为默认print(&apos;Date range of dataset: %s - %s&apos;%(data.loc[1, &apos;starttime&apos;], data.loc[len(data)-1, &apos;stoptime&apos;])) Output：1Date range of dataset: 10/13/2014 10:32 - 9/1/2016 0:20 接下来是这些代码的含义：主要是data.reset_index()这个函数。这个的意义就是排序之后索引会乱，需要reset一下，已恢复默认索引。 艾瑞克的分析结果如下： 这个数据是从2014年10月到2016年9月 从时间上来看，共享单车系统的工作时间远超过955. 按用户类型分析南希认为短期的通行证用户（普通用户）会比正式会员使用更多次自行车。她还认为大部分人都会用一次自行车付一次钱，而不会购买长期会员。艾瑞克不这么认为。他认为新用户刚开始会选择一次一结，但一旦他们对这个服务感到满意或尝到甜头之后，就会充值成为长期会员。他还断定长期会员会更加频繁的使用单车（因为害怕亏本）。于是他对用户类型和骑车次数做了一个柱状图，代码如下： 123groupby_user=data.groupby(&apos;usertype&apos;).size()#根据用户类型分组groupby_user.plot.bar(title=&apos;Distribution of user types&apos;)plt.show()#显示柱状图 Output: 这个表明显揭示了艾瑞克的观点是正确的。 按性别分析南希之前阅读过一篇谈论两性之间的不同的文章，里面说到两性之间连骑自行车的次数都不相同：在英国，有77%的共享单车用户为男性。南希不太确定这个现象是否在美国也存在。于是艾瑞克开始用代码分析这个问题：123groupby_gender=data.groupby(&apos;gender&apos;).size()groupby_gender.plot.bar(title=&apos;Distribution of gender&apos;)#根据性别分组plt.show() Output: 南希根据图表看出了的确存在相同的现象。 按年龄段分析南希做为市场营销，她想知道她的目标客户更多的信息以便知道公司的营销策略要符合什么人群的胃口。于是艾瑞克开始了对用户年龄段的分析： 1234data = data.sort_values(by=&apos;birthyear&apos;)groupby_birthyear = data.groupby(&apos;birthyear&apos;).size()groupby_birthyear.plot.bar(title = &apos;Distribution of birth years&apos;, figsize = (15,4))plt.show() （这个地方的Output出现了一些问题，导致用户最多的年龄段是1931年。。。。其实是1987年。不知道出现了什么问题） 通过分析，南希知道了用户大多数都是Generation Y（即80后，也叫millennials）。她又从一篇报道上得知这一代人一般都会对自己最喜欢的牌子非常忠诚。理由之一就是他们会不厌其烦的对自己喜欢的产品、服务提出改进意见。这些意见都是非常宝贵的经验。而公司改进之后，他们又更加的喜欢这个品牌。于是南希认为这一代人绝大多数都是长期会员。于是艾瑞克决定画一个柱状图来看看南希分析的是否正确： 1234data_mil=data[(data[&apos;birthyear&apos;]&gt;=1977)&amp;(data[&apos;birthyear&apos;]&lt;1994)]groupby_mil=data_mil.groupby(&apos;usertype&apos;).size()groupby_mil.plot.bar(title=&apos;Distribution of user types&apos;)plt.show() Output： 根据柱状图，艾瑞克非常惊讶南希说对了。 结尾艾瑞克知道如果用多个变量分析的话，能够得到更多的信息。于是他开始多变量分析。至此，单变量分析完毕。 线性回归中的平方误差函数：J(\theta_0, \theta_1) = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left ( \hat{y}_{i}- y_{i} \right)^2 = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left (h_\theta (x_{i}) - y_{i} \right)^2]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax使用]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2FMathJax%E5%9C%A8Hexo%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MathJax使用 此文转载于作业部落 LaTeX的数学公式有两种：行中公式和独立公式。行中公式放在文中与其它文字混编，独立公式单独成行。 行中公式可以用如下两种方法表示：＼(数学公式＼) 或 $数学公式 $独立公式可以用如下两种方法表示：＼[数学公式＼] 或 $$ 数学公式 $$ 例子：＼$[J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha}＼]$ 显示 $[J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha}]$ 如何输入上下标^表示上标,_表示下标。如果上下标的内容多于一个字符，要用{}把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。 例子：$x^{y^z}=(1+{\rm e}^x)^{-2xy^w}$显示：$x^{y^z}=(1+{\rm e}^x)^{-2xy^w}$ 另外，如果要在左右两边都有上下标，可以用\sideset例子：$\sideset{^1_2}{^3_4}\bigotimes$ 显示: $$\max_{k}$$ \max_{k}$$\mathop{argmax}_{K}$$ \mathop{argmax}_{K}如何显示希腊字母例子：123456\alpha A \beta B \gamma \Gamma \delta \Delta \epsilon E \varepsilon \zeta Z \eta H \theta \Theta \vartheta \iota I \kappa K \lambda \Lambda \mu M \nu N \xi \Xi o O \pi \Pi \varpi \rho P \varrho \sigma \Sigma \varsigma \tau T \upsilon \Upsilon \phi \Phi \varphi \chi X \psi \Psi \omega \Omega 显示：123456\alpha A \beta B \gamma \Gamma \delta \Delta \epsilon E \varepsilon \zeta Z \eta H \theta \Theta \vartheta \iota I \kappa K \lambda \Lambda \mu M \nu N \xi \Xi o O \pi \Pi \varpi \rho P \varrho \sigma \Sigma \varsigma \tau T \upsilon \Upsilon \phi \Phi \varphi \chi X \psi \Psi \omega \Omega 如何输入其他特殊字符关系运算符：12345678910111213141516171819±：\pm ×：\times ÷：\div ∣：\mid ∤：\nmid ⋅：\cdot ∘：\circ ∗：\ast ⨀：\bigodot ⨂：\bigotimes ⨁：\bigoplus ≤：\leq ≥：\geq ≠：\neq ≈：\approx ≡：\equiv ∑：\sum ∏：\prod ∐：\coprod 集合运算符12345678910111213∅：\emptyset ∈：\in ∉：\notin ⊂：\subset ⊃：\supset ⊆：\subseteq ⊇：\supseteq ⋂：\bigcap ⋃：\bigcup ⋁：\bigvee ⋀：\bigwedge ⨄：\biguplus ⨆：\bigsqcup 对数运算符123log：\log lg：\lg ln：\ln 三角运算符123456789⊥：\bot ∠：\angle 30∘：30^\circ sin：\sin cos：\cos tan：\tan cot：\cot sec：\sec csc：\csc 微积分运算符123456789′：\prime ∫：\int ∬：\iint ∭：\iiint ⨌：\iiiint ∮：\oint lim：\lim ∞：\infty ∇：\nabla 逻辑运算符1234567∵：\because ∴：\therefore ∀：\forall ∃：\exists ≠：\not= ≯：\not&gt; ⊄：\not\subset 戴帽符号 $\hat{y}$ :\hat{y}$\check{y} $：\check{y}$ \breve{y}$：\breve{y} 连线符号 $\overline{a+b+c+d} $:\overline{a+b+c+d}$\underline{a+b+c+d} $:\underline{a+b+c+d} $\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$:\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0} 箭头符号123456789101112↑：\uparrow ↓：\downarrow ⇑：\Uparrow ⇓：\Downarrow →：\rightarrow ←：\leftarrow ⇒：\Rightarrow ⇐：\Leftarrow ⟶：\longrightarrow ⟵：\longleftarrow ⟹：\Longrightarrow ⟸：\Longleftarrow 如何输入分数例子：$\frac{1}{3}$或$1 \over 3$ 显示：$\frac{1}{3}$或$1 \over 3$ 如何输入开方例子： $\sqrt{2}$和$\sqrt[n]{3}$ 显示：$\sqrt{2}$ 和$\sqrt[n]{3}$ 如何输入省略号数学公式中常见的省略号有两种，\ldots表示与文本底线对齐的省略号，\cdots表示与文本中线对齐的省略号。 例子：$f(x_1,x_2,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$ 显示：$f(x_1,x_2,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$ 如何输入矢量例子：$\vec{a} \cdot \vec{b}=0$ 显示：$\vec{a} \cdot \vec{b}=0$ 如何输入积分例子：$\int_0^1 x^2 {\rm d}x$ 显示： $\int_0^1 x^2 {\rm d}x$ 如何输入极限例子： $\lim\limits_{n \rightarrow +\infty} \frac{1}{n(n+1)}$和$$\lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}$$ 显示： $\lim\limits_{n \rightarrow +\infty} \frac{1}{n(n+1)}$ \lim_{n \rightarrow +\infty} \frac{1}{n(n+1)} 注:在latex中输入极限，主要的一种形式是使用\lim，输出的就是极限的原样。如果在$*****$环境中，使用上下标起不到作用，在$$******$$中使用下标，会使下标部分出现在limit之下。在文章中间，使用这种形式的极限，可以选择使用这种形式\lim\limits_{t \to \infty }{x(t)}.上下极限的输入textfriend里面直接就有。另外一点需要注意的是，极限的下标如果有多行的话，使用断行，有几种方法：可以使用array或者substack命令，也可以使用\stackrel{top}{bot}或者mathop命令. 如何输入累加，累乘例子： $\sum_{i=0}^n \frac{1}{i^2}$和$\prod_{i=0}^n \frac{1}{i^2}$显示：$\sum_{i=0}^n \frac{1}{i^2}$$\prod_{i=0}^n \frac{1}{i^2}$ 如何进行公式应用例子： $r = r_F+ \beta(r_M – r_F) + \epsilon$ 显示：$r = r_F+ \beta(r_M – r_F) + \epsilon$ 如何输入括号和分隔符123456`()、[]和|表示自己，&#123;&#125;表示&#123;&#125;。当要显示大号的括号或分隔符时，要用\left和\right命令。`例子：`$f(x,y,z) = 3y^2z \left( 3+\frac&#123;7x+5&#125;&#123;1+y^2&#125; \right)$`有时候要用`\left`或者`\right`进行匹配而不显示本身例子 : `$\left. \frac&#123;&#123;\rm d&#125;u&#125;&#123;&#123;\rm d&#125;x&#125; \right| _&#123;x=0&#125;$`]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%E6%97%A5%E5%B8%B8%2FHello-World%2F</url>
    <content type="text"><![CDATA[Hello World]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[V2Ray搭建详细图文教程]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2019-05-03-V2Ray%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[转自github上的233boy 搭建 V2Ray 看这篇文章就够了！这是完完全全为小白准备的 V2Ray 搭建教程，详细的图文教程确保你可以百分百成功搭建 V2Ray 使用。 前言 此 V2Ray 教程完完全全是为小白准备的，从购买 VPS 到使用 SSH 登录并使用 V2Ray 一键安装脚本配置 V2Ray，详细的图文教程确保你可以百分百成功搭建 V2Ray 使用，哪怕你只是一个小白。 由于 V2Ray 的配置对于小白来说是非常不友好的，所以此 V2Ray 教程的 V2Ray 服务器端配置将会使用我本人撰写的 V2Ray 一键安装脚本，这是一个对小白友好的 V2Ray 一键脚本，简化 V2Ray 安装和部署，并且自动开启 BBR 优化，当然你也可以手动打开 BBR 来优化 V2Ray，也可以选择使用锐速来 优化 V2Ray。 V2Ray 简介 官网：https://www.v2ray.com V2Ray(Project V) 相对于 Shadowsocks，V2Ray 更像全能选手，拥有更多可选择的协议 / 传输载体 (Socks、HTTP、TLS、TCP、mKCP、WebSocket )，还有强大的路由功能，不仅仅于此，它亦包含 Shadowsocks 组件，你只需要安装 V2Ray，你就可以使用所有的 V2Ray 相关的特性包括使用 Shadowsocks，由于 V2Ray 是使用 GO 语言所撰写的，天生的平台部署优势，下载即可使用，当然啦，由于 V2Ray 的配置相对来说是很繁琐的，毫无夸张的说，但是有了本人所写的 V2Ray 一键安装脚本 加持下，使用 V2Ray 便会显得轻松多了。 备注 总结一下此文章的大致流程，此 V2Ray 教程可百分百帮助你搭建 V2Ray 使用。哪怕你只是一个小白。 购买一个 VPS 想要搭建 V2Ray，就必须要拥有一台 VPS。 获取 VPS 信息 我们必须要知道 VPS IP 地址，root 用户密码，SSH 端口 安装 Xshell Xshell 是一个 SSH 客户端，要登录 VPS，当然需要 SSH 客户端 登录 VPS 使用 Xshell 配置 VPS SSH 信息，然后登录 安装 V2Ray 安装过程你可以随意选择你喜欢的传输协议或者配置 Shadowsocks V2Ray 安装完成 此时你可以使用客户端配置 V2Ray 使用了 V2Ray 高级玩法 配置 WebSocket + TLS ， HTTP/2 ， mKCP 等 购买一个VPS 拥有一个 VPS 是必需的。 选择合适的VPS套餐，VPS套餐来自：搬瓦工（Bandwagon Host） 备注：按住 Ctrl + 单击， 即可在新窗口打开链接 推荐购买的套餐如下 线路 CPU 内存 硬盘 带宽 流量 价格 链接 香港 2 核 8192 MB 160 GB 1 G 500GB / 月 $79.99 / 月 购买 香港 4 核 16384 MB 320 GB 1 G 1000GB / 月 $159.99 / 月 购买 香港 6 核 32768 MB 640 GB 1 G 2000GB / 月 $319.99 / 月 购买 香港 6 核 32768 MB 640 GB 1 G 4000GB / 月 $599.99 / 月 购买 - - - - - - - - CN2 GIA 2 核 1 GB 20 GB 2.5 G 1000GB / 月 $65.99 / 半年 购买 CN2 GIA 3 核 2 GB 40 GB 2.5 G 2000GB / 月 $69.99 / 季 购买 CN2 GIA 4 核 4 GB 80 GB 2.5 G 3000GB / 月 $49.99 / 月 购买 CN2 GIA 6 核 8 GB 160 GB 5 G 5000GB / 月 $75.99 / 月 购买 CN2 GIA 8 核 16 GB 320 GB 5 G 8000GB / 月 $139.99 / 月 购买 CN2 GIA 10 核 32 GB 640 GB 10 G 10000GB / 月 $249.99 / 月 购买 CN2 GIA 12 核 64 GB 1280 GB 10 G 12000GB / 月 $479.99 / 月 购买 - - - - - - - - CN2 GIA 1 核 512 MB 10 GB 1 G 300GB / 月 $39.99 / 年 购买 CN2 GIA 1 核 512 MB 10 GB 1 G 500GB / 月 $49.99 / 年 购买 CN2 GIA 2 核 1024 MB 20 GB 1 G 1000GB / 月 $25.99 / 季 购买 CN2 GIA 3 核 2048 MB 40 GB 1 G 2000GB / 月 $51.99 / 季 购买 CN2 GIA 4 核 4096 MB 80 GB 1 G 3000GB / 月 $32.99 / 月 购买 CN2 GIA 6 核 8GB 160 GB 1 G 5000GB / 月 $62.99 / 月 购买 CN2 GIA 8 核 16GB 320 GB 1 G 8000GB / 月 $119.99 / 月 购买 - - - - - - - - CN2 1 核 1024 MB 20 GB 1 G 1000GB / 月 $49.99 / 年 购买 CN2 1 核 2048 MB 40 GB 1 G 2000GB / 月 $52.99 / 半年 购买 CN2 2 核 4096 MB 80 GB 1 G 3000GB / 月 $59.99 / 季 购买 CN2 2 核 8 GB 160 GB 1 G 5000GB / 月 $39.99 / 月 购买 CN2 3 核 16 GB 320 GB 1 G 8000GB / 月 $79.99 / 月 购买 - - - - - - - - 普通 2 核 1024 MB 20 GB 1 G 1 TB / 月 $49.99 / 年 购买 普通 3 核 2 GB 40 GB 1 G 2 TB / 月 $52.99 / 半年 购买 普通 4 核 4 GB 80 GB 1 G 3 TB / 月 $19.99 / 月 购买 普通 5 核 8 GB 160 GB 1 G 4 TB / 月 $39.99 / 月 购买 普通 6 核 16 GB 320 GB 1 G 5 TB / 月 $79.99 / 月 购买 普通 7 核 24 GB 480 GB 1 G 6 TB / 月 $119.99 / 月 购买 选择哪个套餐？如果你不知道选择哪个套餐 下面这是最常见的购买套餐 线路 CPU 内存 硬盘 带宽 流量 价格 链接 普通 2 核 1024 MB 20 GB 1 G 1 TB / 月 $49.99 / 年 购买 CN2 1 核 1024 MB 20 GB 1 G 1000GB / 月 $49.99 / 年 购买 CN2 GIA 1 核 512 MB 10 GB 1 G 300GB / 月 $39.99 / 年 购买 CN2 GIA 1 核 512 MB 10 GB 1 G 500GB / 月 $49.99 / 年 购买 CN2 GIA 2 核 1 GB 20 GB 2.5 G 1000GB / 月 $65.99 / 半年 购买 香港 2 核 8192 MB 160 GB 1 G 500GB / 月 $79.99 / 月 购买 没有找到合适的套餐？你可以前往官网详细查看：https://bwh8.net/cart.php 哪个套餐好？ 一般来说，推荐购买 香港线路 或 CN2 GIA 线路，或者哪个便宜选择那个，说着当然如果你使用量比较多或者想要分享给同学和朋友一起用的话，选择合适的套餐即可。又或者你土豪的话，选择最贵的也行。 VPS 速度：香港线路 &gt; CN2 GIA 线路 &gt; CN2 线路 &gt; 普通线路 香港套餐 VPS 的速度最快。 如果你非常在乎速度的话，建议购买香港线路的 VPS，当然，但价格贵，流量相对其他套餐来说也是比较少的……退一步的选择是 CN2 GIA 线路，这个线路的速度也比较好。 线路是比较重要的，像香港和 CN2 GIA 线路到晚上一般不会怎么炸，其他的到了晚上可能会出现很慢慢的感觉。 我本人比较推荐 CN2 GIA 线路，稳定性，速度与价格适中选择，当然啦！如果你觉得价格太贵了，推荐你查看一下 搬瓦工 Just My Socks ，搬瓦工官方出品的代理服务，同样是 CN2 GIA 线路，每月仅需 $2.88 起！再也不用自己折腾搭建了，更不用担心 IP 被墙问题！ Just My Socks 购买教程在这里： 搬瓦工 Just My Socks 详细图文购买教程 毫无疑问！绝对的一分钱一分货。 如果出现 out of stock 这样的提示，那就是这个套餐卖完了，选择其他套餐即可。 添加到购物车 在上面表格中选择想要购买的套餐，然后点击 购买 即可。 将 VPS 添加到购物车 说明一下，在Billing Cycle选项那里选择：$xxxx USD Annually，按年付的意思 推荐按年付，比按月付最高可省55%的钱 Location 选择: HK - Hong Kong xxxxx （如果你购买的是香港线路的话） 否则选择: US - Los Angeles xxxxx 然后点击Add To Cart 结算 推荐使用搬瓦工 6.25% 优惠码：BWH26FXH3HIQ 这个优惠码是搬瓦工目前最高优惠的优惠码 输入优惠码之后点击 Validate Code &gt;&gt; 然后点击 Checkout 如下图所示：已经使用搬瓦工优惠码 然后会提示你注册账号 （如果你没账号或者还没登录） 请按照下面图片提示来填写~ 要注意的是，Country 选项记得选择 China，Payment Method 选择 Alipay 不要忘了勾上 I have read and agree to the Terms of Service 然后 Complete Order 付款 点击 Pay now 之后便会跳转到支付宝付款界面，完成付款即可 获取VPS信息 备注：按住 Ctrl + 单击， 即可在新窗口打开链接 确保你已经成功付款之后 打开：https://bwh8.net/clientarea.php?action=products 选择 KiwiVM Control Panel 如果出现以下界面，稍等一会，等待资源分配即可。 等待两三分钟，刷新一下。 这是已经在运行的界面，请记下 IP address然后点击 stop 当出现：Great Success! Virtual server will stop in a few seconds. 相关提示 证明 VPS 已经停止了，我们需要重装一个系统。点击左边的 Install new OS 之后选择 debian-9-x86_64 再勾上：I agree that all existing data on my VPS will be lost. 然后点击 Reload 当点击 Reload 之后，稍等片刻将会出现下图所示的界面， 请务必记下： You will need a new root password to access your VPS：xxxx 还有：New SSH Port: 一个是root密码，一个是SSH端口 OK，这时我们已经获取到VPS的信息了。 安装 Xshell 备注：按住 Ctrl + 单击， 即可在新窗口打开链接 Xshell 是一个易用的 SSH 客户端，要登录 VPS，当然需要 SSH 客户端 Xshell 下载链接点我 这是一个绿色版本的 Xshell ，打开链接后，就点击 下载，下载好了之后，就双击打开，然后点击 浏览... 可以选择解压的路径，比如说 D 盘，之后再选择 解压 即可。 然后在解压的目录找到 Xshell+Xftp 绿色版本 文件夹，打开它，之后找到 !安装.bat 并且右键选择 以管理员身份运行，安装完成后会有一个提示窗口，关闭即可。这样来就安装好了 Xshell 登录VPS 在桌面找到 Xshell ，打开它，新建一个会话。 主机写上你的 VPS IP 地址，端口写上 SSH 端口。 之后点击 用户身份验证，用户名：root，密码：你的 root 密码。然后点击确定 之后选择连接。 然后会提示SSH安全警告，选择，接受并保存。 这是登录成功后的界面 安装 V2Ray 输入下面命令回车，你可以复制过去，然后在 Xshell 界面按 Shift + Insert 即可粘贴，不能按 Ctrl + V 的。。 bash &lt;(curl -s -L https://git.io/v2ray.sh) 如果提示 curl: command not found ，那是因为你的 VPS 没装 Curl ubuntu/debian 系统安装 Curl 方法: apt-get update -y &amp;&amp; apt-get install curl -y centos 系统安装 Curl 方法: yum update -y &amp;&amp; yum install curl -y 安装好 curl 之后就能安装脚本了 然后选择安装，即是输入 1 回车 选择传输协议，如果没有特别的需求，使用默认的 TCP 传输协议即可，直接回车 选择端口，如果没有特别的需求，使用默认的端口即可，直接回车 是否屏蔽广告，除非你真的需要，一般来说，直接回车即可 是否配置 Shadowsocks ，如果不需要就直接回车，否则就输入 Y 回车 Shadowsocks 端口，密码，加密方式这些东西自己看情况配置即可，我个人当然是全部直接回车。。 OK，按回车继续 安装信息，如果确保没有什么问题了，按回车继续 (备注，安装信息会因你的配置而变化..不用在乎这截图) (备注，由于我懒&hellip;脚本显示的一些信息可能会跟上面的截图有少许不同，但实际上都是很简单明了的) V2Ray 安装完成 OK，此时 V2Ray 已经安装完成了。 如上图所示，V2Ray 配置信息，Shadowsocks 配置信息都有了 如果你使用过 Shadowsocks ，那么现在你可以测试一下 Shadowsocks 配置了，看看是否能正常使用。 如果你使用过 V2Ray 某些客户端，那么现在也可以测试一下配置了。 (备注，可能某些 V2Ray 客户端的选项或描述略有不同，但事实上，上面的 V2Ray 配置信息已经足够详细，由于客户端的不同，请对号入座。) V2Ray 客户端使用教程 暂停一下，我想，看这篇的孩子多数都是萌新，由于 V2Ray 已经安装完成了，所以此时你应该尝试使用 V2Ray 来连接上真正的互联网了。 Windows V2RayN使用教程 V2Ray 管理面板 现在可以尝试一下输入 v2ray 回车，即可管理 V2Ray TCP 阻断 如果你觉得你的小鸡出现了这种情况，那么可以尝试使用 UDP 协议相关的 mKCP 当然，用了我的脚本那是很简单的啦，直接输入 v2ray config 然后选择修改 V2Ray 传输协议 之后再选择 mKCP 相关的就行咯 备注：使用 mKCP 或许还可以提高速度，但由于 UDP 的原因也许会被运营商 Qos，这是无解的。 快速管理 V2Ray v2ray info 查看 V2Ray 配置信息 v2ray config 修改 V2Ray 配置 v2ray link 生成 V2Ray 配置文件链接 v2ray infolink 生成 V2Ray 配置信息链接 v2ray qr 生成 V2Ray 配置二维码链接 v2ray ss 修改 Shadowsocks 配置 v2ray ssinfo 查看 Shadowsocks 配置信息 v2ray ssqr 生成 Shadowsocks 配置二维码链接 v2ray status 查看 V2Ray 运行状态 v2ray start 启动 V2Ray v2ray stop 停止 V2Ray v2ray restart 重启 V2Ray v2ray log 查看 V2Ray 运行日志 v2ray update 更新 V2Ray v2ray update.sh 更新 V2Ray 管理脚本 v2ray uninstall 卸载 V2Ray 优化 V2Ray 由于本人的脚本在 Debian9 系统会自动开启 BBR 优化加速了，所以不需要再安装 BBR 优化了， 如果你还是觉得网络比较慢的话，你可以尝试使用含有 mKCP 的传输协议，这个 mKCP 的东东，简单一点说就像 Kcptun 一样加速，并且还能进行伪装 (可选)，但是由于 mKCP 是使用 UDP 协议的，也许运营商会限速得更加厉害，网络变得更加慢。但不管怎么样，你都可以随时尝试一下。 服务器输入 v2ray config 回车，然后选择 修改 V2Ray 传输协议，再接着选择 mKCP 相关的传输协议即可 如果你是使用其他商家的 VPS 并且是按照此教程流程来安装 V2Ray 的话，那么你可以输入 v2ray bbr 回车，然后选择安装 BBR 或者 锐速 来优化 V2Ray 只是还想再啰嗦一下，如果你是使用国际大厂的 VPS，并且是按照此教程流程来安装 V2Ray 的话，请自行在安全组 (防火墙) 开放端口和 UDP 协议 (如果你要使用含有 mKCP 的传输协议) WebSocket + TLS 实现 WebSocket + TLS 超级无敌简单，前提是要拥有一个能正常解析的域名 (并且知道怎么解析域名) 服务器输入 v2ray config 回车，然后选择 修改 V2Ray 传输协议，再选择 WebSocket + TLS，即是输入 4，接着输入你的域名，然后我都懒得说了，脚本都那么简单明了，我还瞎BB干嘛&hellip; 哈哈&hellip;可能有不少人在折腾 V2Ray 实现 WS + TLS 的时候真的是搞到很蛋痛咯，有些人的教程可能说得不是很清楚，或者是直接忽略小白萌新这些亲爱的用户，嗯，小白们好好加油吧，请尽量多学一些基础知识，别总是做伸手党，对于毫无交集的陌生人，人家并没有任何义务要帮你的啊 偷偷跟你说&hellip;使用 WebSocket + TLS 会有断流的问题 多说一句，不要被某些人带节奏，WS + TLS 并不是 V2Ray 的神级配置，该墙还是会墙，墙你不需要理由 备注一下啦，这里我没写怎么教你注册域名啦，怎么解析域名啦，如果你真的想要使用 WebSocket + TLS，那就 自己谷歌摸索一下，其实好简单的啦！ 我本人并没有在使用 WS + TLS (WebSocket + TLS)，我用 TCP，就是用一键脚本全程回车的那种懒人 HTTP/2 实现 HTTP/2 (h2) 也超级无敌简单，和 WebSocket + TLS 一样，也就是只要一个域名就够 服务器输入 v2ray config 回车，然后选择 修改 V2Ray 传输协议，再选择 HTTP/2，即是输入 16，然后………看上面的 WebSocket + TLS 的相关。 备注一下，HTTP/2 相比 WS + TLS (WebSocket + TLS) ，在浏览网页时有一些优势。速度是差不多的啦 mKCP mKCP 这个东东其实就是 KCP 协议，反正你知道是能提速的就行，但是不保证都能提速，还能避免 TCP 阻断，但是也可以会被运营商 Qos. 使用方法：服务器输入 v2ray config 回车，然后选择 修改 V2Ray 传输协议，之后再选择 mKCP 相关的就行 搬瓦工 VPS 速度慢 由于本教程使用了 搬瓦工 VPS 做为教程的一部分，那么相信有些新接触 VPS 的同学可能会是按照教程使用了 搬瓦工 VPS 翻墙。 如果你觉得搬瓦工 VPS 速度慢，你可以尝试修改一下端口，服务器输入 v2ray config ，，然后选择 修改 V2Ray 端口 即可，建议使用常见的端口，比如说 443，当然，为了更加安全隐蔽，你可以直接尝试使用 WebSocket + TLS 或者 HTTP/2 协议，但是使用这两个协议对于没有接触过 域名 的同学相对来说会是比较困难的。 搬瓦工 VPS 速度慢的一个主要原因可能会是因为端口限速，如果你已经修改端口为 443，速度还是慢的话，我建议你尝试使用 mKCP 协议。 Telegram 专用代理 如果你在使用 Telegram 的话，你可以配置一个 Telegram 的专用代理，这样来，在某些情况下你就不需要再开一个代理软件了。 输入 v2ray tg 即可配置 TG 专用代理 配置 Telegram MTProto Telegram MTProto 配置信息 V2Ray 多用户 目前此 V2Ray 一键脚本只支持配置一个 V2Ray 账号&hellip;一个 Shadowsocks 账号 说着当然，如果你是大佬，配置 多用户 这种事，不是分分钟的事么？ 查看配置 / 修改配置 / 端口 / 传输协议…… ？ 请看上面的快速管理。。。或者直接输入 v2ray 回车，找到你想要执行的功能。 哪个传输协议好？ 心中无杂念，用 TCP ISP 常作怪，用 动态端口 小鸡速度不好，用 mKCP 处子之身，用 WS + TLS V2Ray 脚本说明 V2Ray 一键安装脚本 反馈问题 请先查阅：V2Ray 一键安装脚本疑问集合 Telegram 群组： https://t.me/blog233 Github 反馈： https://github.com/233boy/v2ray/issues 任何有关于 V2Ray 的问题，请自行到 V2Ray 官方反馈。 目前只支持配置一个 V2Ray 账号&hellip;一个 Shadowsocks 账号。。不支持 SSR。。 分享 如果这篇文章对你帮助的话，记得分享给你的小伙伴们。 其他 请勿违反国家法律法规，否则后果自负！ 低调低调低调。 资助 V2Ray 如果你觉得 V2Ray 很好用，能解决你的某些问题，请考虑 资助 V2Ray 发展 。 结束 我有写少了什么吗？我这种小小白萌新看了这教程都觉得很明白了啊。 一次不会，那么就两次，还是不会，那就再来一次。可还是不会啊？大佬请收下我的膝盖。 &lt;/div&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中服务器踩坑记录]]></title>
    <url>%2F%E6%97%A5%E5%B8%B8%2F2019-05-02-Ubuntu%E4%B8%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Ubuntu中服务器踩坑记录今天刚恰完饭回来打开电脑准备看看我的毕业设计，发现Apache服务器和Mysql服务统统启动不了了，提示如下图 当时很是懵逼，我寻思着我前几天也没动啊，咋就这样了？linux这么不稳定？然后试着输入命令行systemctl status.mysql.service和systemctl status apache.service,看看啥子情况，mysql的显示如下： 1. apache修复apache的图没有截，但是显示的错误结果非常清楚：Cannot access directory &#39;/var/log/apache2/&#39;，然后我去了目录下面看了看，发现没这个文件夹，我突然想到前几天下了个垃圾清理文件Stacer，可能把我的日志给清了，于是我新建了个目录，给了755权限，然后再启动，成功！ 2. mysql修复然后是mysql的问题，上面的图根本没有显示出问题。。。我在一篇博客下面找到了答案，原来在/var/log/下面还有个syslog文件，里面可看到系统各个进程的日志。于是我看了看mysql的，显示如下： 第一行就有一个报错2019-05-02T07:40:56.158932Z 0 [ERROR] Could not open file &#39;/var/log/mysql/error.log&#39; for error logging: No such file or directory，原来又是那个软件把我mysql的日志文件给清了！艹，而且这服务器也不智能，没有自己创建一个，只会报错。。。然后我在这目录下面创建了这个文件，给了755权限，发现还是启动失败？？？我看了一眼syslog，如图 报错为2019-05-02T07:44:37.657516Z 0 [ERROR] Could not open file &#39;/var/log/mysql/error.log&#39; for error logging: Permission denied，喜闻乐见的Premission denied,于是我给了777权限，启动成功。 3. 小结没啥小结，就是以后再也别用垃圾清理软件随便清理log了！！！]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu配置PPPOE拨号上网]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2019-4-30-ubuntu%E8%AE%BE%E7%BD%AEpppoe%E6%8B%A8%E5%8F%B7%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[PPPOE拨号上网 原文链接 使用pppoeconf命令配置连接信息 1sudo pppoeconf 在终端的类图形界面下，一直选择yes。 输入用户名(记得要删除username)。 输入密码 配置DNS(yes,运行运营商自动配置DNS) 通过pppoe限制MSS的大小,选择yes 计算机启动的时候自动连接，yes 所创建的配置文件目录位于/etc/ppp/peers，文件名即为connection name。 相关命令 启动adsl链接 1sudo pon dsl-provider pon命令详解 pon命令不带参数，首先检测运行/etc/ppp/ppp_on_boot文件，如果不存在就会去 /etc/ppp/peers/文件夹下寻找启动文件。 pon命令带参数，pon myisp；就会使用/etc/ppp/peers/myisp文件 关闭adsl链接 1sudo poff poff命令详解 poff myisp；命令就是关闭myisp连接，如果只有一个adsl链接，可以不带参数直接运行 poff可以带参数：-r 重复拨号.-d 切换PPPD的状态调试选项。-c causes pppd(8) to renegotiate compression.-a 关闭所有的ppp连接-h 显示帮助信息-v 显示版本信息 查看链接的日志 plog12查看连接信息ifconfig ppp0 ppp0和eth0简单谈一下ppp0和eth0的关系ppp协议是互联网点对点通信协议，属于网络层协议。如果学过网络课程的知识，就会知道，网络结构遵循OSI模型体系结构，而ppp0和eth0是分别属于网络层和物理层的协议。其中ip配置是属于网络层结构，也就是ppp0所负责的。eth0是是物理层（网卡所在层）主要负责记录网络的物理地址。所以网络层需要依赖于物理层eth0的激活。 networkmanager和pppoeconfnetworkmanager是网络管理器，主要管理linux下的所支持的网络连接，图形界面很强大。而pppoeconf是专门管理pppoe拨号的网络管理器，主要是终端运行。 网卡相关操作 12345678910启动网卡sudo ifup eth0关闭网卡sudo ifdown eth0重启网络的命令sudo /etc/init.d/networking restart //会重新读取配置文件ubuntu网络配置文件：/etc/network/interfaces ubuntu下网络详细配置的博文地址：http://www.2cto.com/os/201404/292853.htmlnetworkmanager和终端网络配置的关系：http://blog.csdn.net/anhuidelinger/article/details/17584299/更详细的一篇博文：http://wiki.ubuntu.org.cn/ADSL%EF%BC%88PPPOE%EF%BC%89%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github的图床制作]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2019-04-30-github%E5%9B%BE%E5%BA%8A%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Github的图床制作 灵感来源CSDN 1. Github仓库设置1.1 新建仓库先创建个新库，权限选为public，我的叫img： 1.2 创建token建立仓库之后，点击自己头像，进入设置。 在最下方找到Developer settings，点击进入，进去之后点击最下方的Personal access tokens选项： 如图所示，再点击图中的Generate new token， 填 description（也是随心填），勾选复选框 repo ，接着到页面底部 Generate token 就完成了； 然后复制生成一串字符 token，这个 token 只出现一次，所以要保存一下。 2. PicGo安装配置PicGo （目前 2.0.4）是一个开源的图床工具，非常优秀。可以到 git 上下载。嫌速度慢自己搭梯子。 git地址：PicGo 如图所示， 仓库名 就是你的仓库名 分支名默认是master Token就是刚才复制的那一串 存储路径和域名可填可不填 到最后点确定就行 综上，操作全部完成。 唯一缺点，不能私人，要是传色图有可能被发现（想想也不会有人翻我的git，连这篇博客都不一定有人看），国内我又搞了个阿里云oss，可以私人，但是要备案，懂得都懂，看个人取舍吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[私人用机场推荐]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2019-4-29-%E7%A7%81%E4%BA%BA%E7%94%A8%E6%9C%BA%E5%9C%BA%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[机场推荐最近在google上看到一个比较全面的机场推荐，每个机场还有节点测速，因为还在不断更新，所以就直接放链接了 毒药机场推荐 注：本篇转载文章作者与本人毫无瓜葛，在现实生活中未有任何接触！！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux解压中文密码的压缩文件]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2019-4-29-Linux%E8%A7%A3%E5%8E%8B%E4%B8%AD%E6%96%87%E5%AF%86%E7%A0%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Linux解压中文密码的压缩文件最近遇到个小问题，我在ubuntu下解压某群友发的福利压缩文件（解压密码为中文）时，发现总是提示密码错误。 我第一时间想到了可能是linux和windows编码不同的区别。windows是gbk和utf-8，llinux是标准的utf-8。 导致两个系统的中文不通用。因为我日常使用ubuntu，不会为这点福利就下个windows，所以在网上找来找去，最后在简书上找到了答案。 下面就以unzip命令演示一哈： 1unzip -P &quot;$(echo -n 琴叶酱|iconv -f utf-8 -t gbk)&quot; 某个憨批的桌面文件？.zip 转码部分为1echo -n 琴叶酱|iconv -f utf-8 -t gbk 密码是琴叶酱，-f是from，-t是to。，语句意思为将echo输出的字符串从utf-8转码为gbk。 如果是从windows解压linux加密的压缩文件的话，将utf-8和gbk调换位置即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%2F2019-4-28-Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown 基本语法 转载自简书 Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 相比WYSIWYG编辑器 优点:1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点：1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。 一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 示例：# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 示例： **这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例： &gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： -------******** 效果如下：可以看到显示效果是一样的。 —- 五、图片语法：1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例：12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下：（这个链接可能坏了） 六、超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例：12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下：简书百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 七、列表 无序列表 语法：无序列表用 - + * 任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 有序列表 语法：数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下： 1.列表内容2.列表内容3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级 二级 -三 级 一级无序 1.二级有序 一级有序 二级无序 八、表格语法：1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例：12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法：单行：用一个反引号包起来1`代码` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 十、流程图123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 1234567891011效果如下：```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己的第一篇博客]]></title>
    <url>%2F%E6%97%A5%E5%B8%B8%2F2019-04-16-%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[先test一哈马上毕业，先搞个代码块1print(&quot;hello world&quot;) 再搞个代码行完事了，剩下等有时间再写主要搞机器学习和网络安全]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试一下插入图片]]></title>
    <url>%2F%E6%97%A5%E5%B8%B8%2F2019-04-16-%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[试一下Markdown的图片插入，用阿里云插入的，picgo用不了，有点麻烦，要是可以直接复制url就好2]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从一道网易面试题浅谈 Tagged Pointer]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2017-12-26-%E4%BB%8E%E4%B8%80%E9%81%93%E7%BD%91%E6%98%93%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B5%85%E8%B0%88-Tagged-Pointer%2F</url>
    <content type="text"><![CDATA[前言这篇博客九月就想写了，因为赶项目拖了到现在，抓住17年尾巴写吧~ 正文上次看了一篇 《从一道网易面试题浅谈OC线程安全》 的博客，主要内容是： 作者去网易面试，面试官出了一道面试题：下面代码会发生什么问题？ 12345678@property (nonatomic, strong) NSString *target;//....dispatch_queue_t queue = dispatch_queue_create("parallel", DISPATCH_QUEUE_CONCURRENT);for (int i = 0; i &lt; 1000000 ; i++) &#123; dispatch_async(queue, ^&#123; self.target = [NSString stringWithFormat:@"ksddkjalkjd%d",i]; &#125;);&#125; 答案是：会 crash。 我们来看看对target属性（strong修饰）进行赋值，相当与 MRC 中的 1234567- (void)setTarget:(NSString *)target &#123; if (target == _target) return; id pre = _target; [target retain];//1.先保留新值 _target = target;//2.再进行赋值 [pre release];//3.释放旧值&#125; 因为在 并行队列 DISPATCH_QUEUE_CONCURRENT 中异步 dispatch_async 对 target属性进行赋值，就会导致 target 已经被 release了，还会执行 release。这就是向已释放内存对象发送消息而发生 crash 。 但是我敲了这段代码，执行的时候发现并不会 crash~ 12345678@property (nonatomic, strong) NSString *target;dispatch_queue_t queue = dispatch_queue_create("parallel", DISPATCH_QUEUE_CONCURRENT);for (int i = 0; i &lt; 1000000 ; i++) &#123; dispatch_async(queue, ^&#123; // ‘ksddkjalkjd’删除了 self.target = [NSString stringWithFormat:@"%d",i]; &#125;);&#125; 原因就出在对 self.target 赋值的字符串上。博客的最后也提到了 - ‘上述代码的字符串改短一些，就不会崩溃’，还有 Tagged Pointer 这个东西。 我们将上面的代码修改下： 123NSString *str = [NSString stringWithFormat:@"%d", i];NSLog(@"%d, %s, %p", i, object_getClassName(str), str);self.target = str; 输出： 10, NSTaggedPointerString, 0x3015 发现这个字符串类型是 NSTaggedPointerString，那我们来看看 Tagged Pointer 是什么？ Tagged PointerTagged Pointer 详细的内容可以看这里 深入理解Tagged Pointer。 Tagged Pointer 是一个能够提升性能、节省内存的有趣的技术。 Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和 NSDate（后来可以存储小字符串） Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。 它的内存并不存储在堆中，也不需要 malloc 和 free，所以拥有极快的读取和创建速度。 参考： 从一道网易面试题浅谈OC线程安全 深入理解Tagged Pointer 【译】采用Tagged Pointer的字符串]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为博客添加 Gitalk 评论插件]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2017-12-19-%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-Gitalk-%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言由于 Disqus 对于国内网路的支持十分糟糕，很多人反映 Disqus 评论插件一直加载不出来。而我一直是处于翻墙状态的~（话说你们做程序员的都不翻墙用Google的吗😅，哈哈，吐嘈下） 针对这个问题，我添加了Gitalk 评论插件。在此，非常感谢 @FeDemo 的推荐 。 正文Gitalk 评论插件首先来看看 Gitalk 的界面和功能： gitalk 使用 Github 帐号登录，界面干净整洁，最喜欢的一点是支持 MarkDown语法。 原理Gitalk 是一个利用 Github API,基于 Github issue 和 Preact 开发的评论插件，在 Gitalk 之前还有一个 gitment 插件也是基于这个原理开发的,不过 gitment 已经很久没人维护了。 可以看到在 gitalk 的评论框进行评论时，其实就是在对应的 issue 上提问题。 集成 Gitalk到这里，你应该对 Gitalk 有个大致的了解了，现在，开始集成 gitalk 插件吧。 将这段代码插入到你的网站： 1234567891011121314151617181920212223&lt;!-- Gitalk 评论 start --&gt;&#123;% if site.gitalk.enable %&#125;&lt;!-- Link Gitalk 的支持文件 --&gt;&lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt;&lt;script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"&gt;&lt;/script&gt;&lt;div id="gitalk-container"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var gitalk = new Gitalk(&#123; // gitalk的主要参数 clientID: `Github Application clientID`, clientSecret: `Github Application clientSecret`, repo: `存储你评论 issue 的 Github 仓库名`, owner: 'Github 用户名', admin: ['Github 用户名'], id: '页面的唯一标识，gitalk会根据这个标识自动创建的issue的标签', &#125;); gitalk.render('gitalk-container');&lt;/script&gt;&#123;% endif %&#125;&lt;!-- Gitalk end --&gt; 我们需要关心的就是配置下面几个参数： 123456clientID: `Github Application clientID`,clientSecret: `Github Application clientSecret`,repo: `Github 仓库名`,//存储你评论 issue 的 Github 仓库名（建议直接用 GitHub Page 的仓库名）owner: 'Github 用户名',admin: ['Github 用户名'], //这个仓库的管理员，可以有多个，用数组表示，一般写自己,id: 'window.location.pathname', //页面的唯一标识，gitalk 会根据这个标识自动创建的issue的标签,我们使用页面的相对路径作为标识 当然，还有其他很多参数，有兴趣的话可以 点这里。 比如我就增加了这个全屏遮罩的参数。 1distractionFreeMode: true, 创建 Github ApplicationGitalk 需要一个 Github Application，点击这里申请。 填写下面参数： 点击创建 获取 Client ID 和 Client Secret 填入你的我们 Gitalk 参数中 当你参数都设置好，将代码推送到 Github 仓库后，没什么问题的话，当你点击进入你的博客页面后就会出现评论框了。 当你用 github 帐号登录（管理员），并且第一次加载该会比较慢，因为第一次加载会自动在你 repo 的仓库下创建对应 issue。 比如说这样： 当然，你也可以手动创建issue作为 gitalk评论容器。只要有 Gitalk 标签 和 id 对应标签就可以。比我我自己创建的 About issue 。 结语最后说几句吐嘈几句， Gitalk 需要你点开每篇文章的页面才会创建对应的 issue,对我来说真是个糟糕的体验（文章有点多~）。 当然，也有解决办法，这篇 自动初始化 Gitalk 和 Gitment 评论，就解决了这个问题。 最后，给个 star 吧~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD 在 Swift 中的用法]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%2F2017-10-04-GCD-%E5%9C%A8-Swift-%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[DispatchQueueSwift 中，对 GCD 语法进行了彻底改写。引入了 DispatchQueue 这个类。 先来看看在一个异步队列中读取数据， 然后再返回主线程更新 UI， 这种操作在新的 Swift 语法中是这样的： 123456789DispatchQueue.global().async &#123; DispatchQueue.main.async &#123; // 更新UI操作 &#125;&#125; DispatchQueue.global().async 相当于使用全局队列进行异步操作。然后在调用 DispatchQueue.main.async 使用主线程更新相应的 UI 内容。 优先级新的 GCD 引入了 QoS (Quality of Service) 的概念。 先看看下面的代码： 123DispatchQueue.global(qos: .userInitiated).async &#123;&#125; QoS 对应的就是 Global Queue 中的优先级。 其优先级由最低的 background 到最高的 userInteractive 共五个，还有一个未定义的 unspecified。 1234567891011public static let background: DispatchQoSpublic static let utility: DispatchQoSpublic static let `default`: DispatchQoSpublic static let userInitiated: DispatchQoSpublic static let userInteractive: DispatchQoSpublic static let unspecified: DispatchQoS 自定义 Queue除了直接使用 DispatchQueue.global().async 这种封装好的代码外，还可以通过DispatchWorkItem 自定义队列的优先级，特性： 12345let queue = DispatchQueue(label: "swift_queue")let dispatchworkItem = DispatchWorkItem(qos: .userInitiated, flags: .inheritQoS) &#123; &#125;queue.async(execute: dispatchworkItem) GCD定时器Swift 中 dispatch_time的用法改成了： 1234let delay = DispatchTime.now() + .seconds(60)DispatchQueue.main.asyncAfter(deadline: delay) &#123; &#125; 相较与OC来说更易读了： 1let dispatch_time = dispatch_time(DISPATCH_TIME_NOW, Int64(60 * NSEC_PER_SEC)) 参考 GCD 在 Swift 3 中的玩儿法]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 4 新特性]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%2F2017-09-11-Swift-4-%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[private 权限扩大在 Swift 4 中，extension 可以读取 private 变量了。 Swift 3 中，如果将主体函数的变量定义为 private，则其 extension 无法读取此变量，必须将其改为 filePrivate 才可以。 单向区间单向区间是一个新的类型，主要分两种：确定上限和确定下限的区间。直接用字面量定义大概可以写成 …6和 2… 例如 1234let intArr = [0, 1, 2, 3, 4]let arr1 = intArr[...3] // [0, 1, 2, 3]let arr2 = intArr[3...] // [3, 4] 字符串改动String 操作简化了String 许多要通过 .characters 进行的操作，可以直接用 String 进行操作了。 例如： 1234let greeting = "Hello, 😜!"// No need to drill down to .characterslet n = greeting.countlet endOfSentence = greeting.index(of: "!")! 新增 Substring 类型swift 4 为字符串片段新增了一个叫 Substring 的类型。 当你创建一个字符串的片段时，会产生一个 Substring 实例。Substring 与 String 用法相同， 因为子串和原字符串共享内存，所以对子串的操作快速而且高效。 12345678910let greeting = "Hi there! It's nice to meet you! 👋"let endOfSentence = greeting.index(of: "!")! // 产生 Substring 实例let firstSentence = greeting[...endOfSentence]// firstSentence == "Hi there!"// `Substring` 与 `String` 用法相同let shoutingSentence = firstSentence.uppercased()// shoutingSentence == "HI THERE!" 但是要注意一个 Substring 保留从其生成的完整的 String值。 当您传递一个看似很小的 Substring 时，这可能导致意外的高内存开销。所以使用 Substring时，最好转化为 String. 1let newString = String(substring) 换行可以不用 \n了！Swift 3，字符串换行要插入 \n。例如： 在 Swift 4 可以这样操作: 用两个 “”“ 包裹起来的字符串会自动添加 \n 换行，更加直观了。注意：换行与缩进参照的是第二个 “”“ 号的位置。 嗯，我觉得OK！ 支持 Unicode 9Swift 4 支持 Unicode 9，为现代表情符号修正了一些问题。 123let family1 = "👨‍👩‍👧‍👦"let family2 = "👨\u&#123;200D&#125;👩\u&#123;200D&#125;👧\u&#123;200D&#125;👦"family1 == family2 // → true 居然还有这种操作~ 新增 KeyPath 数据类型KeyPath 是 Swift 4 新增加的数据类型。 定义两个结构体 Person与Book 123456789101112131415struct Person &#123; var name: String&#125;struct Book &#123; var title: String var authors: [Person] var primaryAuthor: Person &#123; return authors.first! &#125;&#125;let abelson = Person(name: "Harold Abelson")let sussman = Person(name: "Gerald Jay Sussman")let book = Book(title: "Structure and Interpretation of Computer Programs", authors: [abelson, sussman]) 12345book[keyPath: \Book.title]book[keyPath: \Book.primaryAuthor.name]// 相当与book.titlebook.primaryAuthor.name 这里 \Book.title 与 \Book.primaryAuthor.name 就是 KeyPath. KeyPath 可以用 .appending 拼接 123let authorKeyPath = \Book.primaryAuthorlet nameKeyPath = authorKeyPath.appending(path: \.name)// nameKeyPath = \Book.primaryAuthor.name 新增 swapAt() 函数Swift 4 引入了一种在集合中交换两个元素的新方法: swapAt() Swift 3 交换集合中的元素的用 swap() 123var numbers = [1,2,3,4,5]swap(&amp;numbers[0], &amp;numbers[1])// numbers = [2,1,3,4,5] Swift 4 中可以直接用 123var numbers = [1,2,3,4,5]numbers.swapAt(0,1)// numbers = [2,1,3,4,5] 其他改动其他改动如：新的整数协议、泛型下标、NSNumber bridging等 可以参考：whats new in swift4]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 Debug Memory Graph 检测内测泄漏]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2017-07-26-%E5%88%A9%E7%94%A8-Debug-Memory-Graph-%E6%A3%80%E6%B5%8B%E5%86%85%E6%B5%8B%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[前言平常我们都会用 Instrument 的 Leaks / Allocations 或其他一些开源库进行内存泄露的排查，但它们都存在各种问题和不便， 在这个 ARC 时代更常见的内存泄露是循环引用导致的 Abandoned memory，Leaks 工具查不出这类内存泄露，应用有限。 今天介绍一种简单直接的检测内测泄漏的方法：Debug Memory Graph 就是这货： 正文我最近的项目中，退出登录后（跳转到登录页），发现首页控制器没有被销毁，依旧能接收通知。 退出登录代码： 123UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"Login" bundle:[NSBundle mainBundle]];AppDelegate *appDelegate = (AppDelegate *)[UIApplication sharedApplication].delegate;appDelegate.window.rootViewController = [storyboard instantiateViewControllerWithIdentifier:@"LoginVC"]; 很明显发生了循环引用导致的内测泄漏。 接下来就使用 Debug Memory Graph 来查看内测泄漏了。 运行程序首先启动 Xcode 运行程序。 Debug Memory Graph 点击 Debug Memory Graph 按钮后，可以看到红框内的是当前内存中存在的对象。其中，绿色的就是视图控制器。 这样，我们随时都可以查看内测中存在的对象，换句话说，就是可以通过观察 Memory Graph 查看内测泄漏。 调试你的App继续运行你的程序 然后对App进行调试、push、pop 操作，再次点击 Debug Memory Graph 按钮。那些该释放而依旧在内测中的 控制器 或 对象 就能一一找出来了。 接下来，只要进入对应的控制器找到内测泄漏的代码就OK了，一般是Block里引用了 self，改为 weakSelf 就解决了。 123456#define WS(weakSelf) __weak __typeof(&amp;*self)weakSelf = self;WS(weakSelf)sView.btnBlock = ^(NSInteger idx)&#123; [weakSelf.tableView reloadSections:[NSIndexSet indexSetWithIndex:idx] withRowAnimation:UITableViewRowAnimationAutomatic];&#125;; 结语就这样，利用 Debug Memory Graph，可以简单快速的检测内测泄漏。 一般由两个对象循环引用的内测泄漏是比较好发现的，如果是由三个及其三个以上的对象形成的大的循环引用，就会比较难排查了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTunes Connect 构建版本不显示]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2017-07-24-iTunes-Connect-%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E4%B8%8D%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[前言今天新项目上架，在Xcode打包上传到App Store后，在iTunes Connect构建版本中居然找不到上传的App… 解决从iOS10开始,苹果更加注重对用于隐私的保护,App 里边如果需要访问用户隐私,必须要做描述,所以要在 plist 文件中添加描述。 而这三个基础描述是必须添加的： 麦克风权限：Privacy - Microphone Usage Description 是否允许此App使用你的麦克风？ 相机权限：Privacy - Camera Usage Description 是否允许此App使用你的相机？ 相册权限：Privacy - Photo Library Usage Description 是否允许此App访问你的媒体资料库？ 其他的权限可以根据自己 APP 的情况来添加。 添加完权限之后然后继续提交 App 就可以了。 若还是找不到，返回 plist 文件中，删除之前的权限，重新添加一下，有可能你哪不小心添加的权限末尾有空格，或者字段不对。 End]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift的HMAC和SHA1加密]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%2F2017-07-19-Swift%E7%9A%84HMAC%E5%92%8CSHA1%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）。 HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。也就是说HMAC通过将哈希算法(SHA1, MD5)与密钥进行计算生成摘要。 Objectice-C在上个 Objectice-C 项目中，使用的 HMAC 和 SHA1 进行加密。如下代码： 123456789101112131415+ (NSString *)hmacsha1:(NSString *)text key:(NSString *)secret &#123; NSData *secretData = [secret dataUsingEncoding:NSUTF8StringEncoding]; NSData *clearTextData = [text dataUsingEncoding:NSUTF8StringEncoding]; unsigned char result[20]; // SHA1加密 CCHmac(kCCHmacAlgSHA1, [secretData bytes], [secretData length], [clearTextData bytes], [clearTextData length], result); char base64Result[32]; size_t theResultLength = 32; // 转为Base64 Base64EncodeData(result, 20, base64Result, &amp;theResultLength,YES); NSData *theData = [NSData dataWithBytes:base64Result length:theResultLength]; NSString *base64EncodedResult = [[NSString alloc] initWithData:theData encoding:NSUTF8StringEncoding]; return base64EncodedResult;&#125; swift最近用 swift 重构项目,用 Swift 重写了 HMAC 的 SHA1 加密方式。 使用12// 使用HMAC和SHA加密let hmacResult:String = "myStringToHMAC".hmac(HMACAlgorithm.SHA1, key: "myKey") 代码使用下面代码时，需要在 OC 桥接文件xxx-Bridging-Header中 #import &lt;CommonCrypto/CommonHMAC.h&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253extension String &#123; func hmac(algorithm: HMACAlgorithm, key: String) -&gt; String &#123; let cKey = key.cStringUsingEncoding(NSUTF8StringEncoding) let cData = self.cStringUsingEncoding(NSUTF8StringEncoding) var result = [CUnsignedChar](count: Int(algorithm.digestLength()), repeatedValue: 0) CCHmac(algorithm.toCCHmacAlgorithm(), cKey!, strlen(cKey!), cData!, strlen(cData!), &amp;result) var hmacData:NSData = NSData(bytes: result, length: (Int(algorithm.digestLength()))) var hmacBase64 = hmacData.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.Encoding76CharacterLineLength) return String(hmacBase64) &#125;&#125;enum HMACAlgorithm &#123; case MD5, SHA1, SHA224, SHA256, SHA384, SHA512 func toCCHmacAlgorithm() -&gt; CCHmacAlgorithm &#123; var result: Int = 0 switch self &#123; case .MD5: result = kCCHmacAlgMD5 case .SHA1: result = kCCHmacAlgSHA1 case .SHA224: result = kCCHmacAlgSHA224 case .SHA256: result = kCCHmacAlgSHA256 case .SHA384: result = kCCHmacAlgSHA384 case .SHA512: result = kCCHmacAlgSHA512 &#125; return CCHmacAlgorithm(result) &#125; func digestLength() -&gt; Int &#123; var result: CInt = 0 switch self &#123; case .MD5: result = CC_MD5_DIGEST_LENGTH case .SHA1: result = CC_SHA1_DIGEST_LENGTH case .SHA224: result = CC_SHA224_DIGEST_LENGTH case .SHA256: result = CC_SHA256_DIGEST_LENGTH case .SHA384: result = CC_SHA384_DIGEST_LENGTH case .SHA512: result = CC_SHA512_DIGEST_LENGTH &#125; return Int(result) &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「体能训练理论」之功能性]]></title>
    <url>%2F%E6%97%A5%E5%B8%B8%2F2017-07-10-%E3%80%8C%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA%E3%80%8D%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%80%A7%2F</url>
    <content type="text"><![CDATA[引言体能训练是一种开源的程序它所依仗的并不是固有的方法手段，而是能够贯穿始终的逻辑，它是一种指导实践的思维方式，我们管它叫“体能思路”。 体能思路有两个方向，一个是原点，一个是过程。所谓原点我们认为是人体的本质属性，比如之前我们分享的五大运动素质以及动力链理论。所谓过程是我们分析问题实现目的的思考方向以及逻辑，它主要体现在接下来要跟大家分享的功能性原则和金字塔。 今天先来说功能性原则。 功能性我们所说的功能性是一种解决问题的思维方式，而功能性训练则定义了一种多关节参与，多平面运动的复杂练习。功能性训练是具体的，比较好理解，我就不赘述了，也不评价其优劣，因为在“功能性”的思维方式下，只存在目标之下的合适与否。 什么是功能性？我们把它定义为目标导向下的效率，所以它是一种程度的体现。如果一个练习与目标的相关性强，那么我们认为它具备较强的功能意义；而如果一个练习与它的目标背道而驰，那么我们就认为它缺乏功能意义。 举个例子，对于偏瘫患者来说，一个手指的屈伸就已经具备非常强的功能意义了，而对于一个马拉松爱好者来说，静蹲的价值可能并不是想象中那么高。 一般来说，在思考功能性问题的时候我习惯从以下三个方面入手：肌肉的生理适应 、动作模式 和 专项需求。 1. 肌肉的生理适应其实练肌肉谁都会，是一个相对好入手的技能，但是当你给这个行为赋予体能训练使命的时候就需要思考一些问题，比如说你现在练习所发展的东东真的是你实际运动中所需要的东东么？ 我们都知道肌肉的生理收缩模式可以简单的分为向心收缩，离心收缩和静力收缩。现在的研究表明，这三种收缩模式的练习所产生的适应性提高存在显著的特异性。也就是说我向心练习所发展的能力只在向心运动中表现最好，在离心和静力中都不佳。同样，离心收缩也只能获得最好的离心能力收益。而静力就更变态，其训练最佳效果仅仅体现在所锻炼的关节角度下，换一个角度能够迁移的效果有可能都不到一半儿。这样看来，你的训练是不是并没有达到你想要的效果呢？ 举个例子： 为什么静蹲对于跑步爱好者来说可能并没有那么理想？因为膝关节股四头肌在跑步中以离心缓冲为主，而且角度在伸膝末端的30°左右，而静蹲却是在屈曲90°左右的角度下呆着不动……着不动……不动……动…… 除此之外，需要考虑的问题还很多，比如说发力模式，是加速？减速？还是匀速？再比如关节活动角度上发力点的位置，是伸展末端发力？屈曲极限发力？还是在屈伸过程中的某一点发力？阻力加在哪里，就会在哪里产生最好的适应，那么功能的意义就体现在这里。 2. 动作模式动作模式是动作程序的体现，而基础动作模式是诸多复杂动作模式共性的抽象体现，并且基础动作模式一定是符合解剖结构和生物力学特点的，说白了也就是我们人体被设计来应该完成的动作。 如果说大多数运动都可以认为是基础动作模式的升级与排列组合，同时基础动作模式本身又能衍生出来很多训练动作，那么选择和实际运动相对应的练习就是另一个功能性的体现了。 比如说发展起跳能力，因为跳是蹲的升级，所以我一定首选深蹲练习；再比如说跑步，存在大量的下肢摆动与支撑的交替，摆动可以认为是下肢开链屈髋与蹬伸，而支撑可以认为是下肢单腿蹲的一瞬间，那么我会选择箱式单腿蹲，保加利亚蹲，悬垂屈髋等等；再再比如，拳击是基于“旋转”加“上肢推”加“单腿蹲”的动作模式，那么我就要练习剪蹲…旋转…单臂…推举…吗？ 其实动作模式的选择要结合动力链一起去思考，这里除了要思考开链还是闭链之外，还要考虑动力链的完整性以及发力的顺序或者说是力学结构。说到上肢推的动作模式，水平推的话我相信很多人都会想到卧推和俯卧撑，那么这两个动作的功能性如何评价呢？ 卧推，一个挺奇葩的动作，奇葩在哪呢？来，咱们数数卧推的主动关节都有哪些：肩关节，肘关节。那么我们上肢链在上肢推动作模式下参与的关节都有哪些呢？肩关节，肘关节！就这些么？再想想！其实你还疏漏了一个非常重要的关节——肩胛胸关节！几乎所有上肢的动作都以肩胛胸关节的运动为基础，而卧推却并没有，特别是标准的卧推~ 俯卧撑，虽然肩胛胸，肩关节，肘关节全面参与到运动中去，但不巧的是它是一个闭链运动，而实际运动中我们的上肢会以开链为主！呵呵~ 别着急，认真你就输了！上面两段其实是个伪命题，我这么做主要是想通过这个平易近人的例子来帮助大家掌握的分析问题的思路！如果你需要发展上肢最大力量表现，那么显然卧推是你的首选。而如果你要优化上肢的力学结构，特别是水平推的发力顺序，那么俯卧撑是你首选。再如果你要提高上肢的延展性以及伴随旋转的加速能力，那么单臂水平推的练习给你的帮助最大！ 所以，选择什么，看目标喽~ 3. 专项需求其实这个非常好理解，也是功能性原则的根本目的，但是为了和上面两个方向区分开，这里主要针对的是不同的运动素质需求。 Q：对一个英超的后卫进行长距离高强度的游泳练习是否具备功能性意义？！ A：具备！ Q：为什么？ A：因为他喜欢游泳，这个可以让他心情愉悦然后更好的训练和比赛！ 咳咳！当然，这样的答案是合情合理的！但是我们不妨换一个角度去分析。 英超，几乎是足球联赛中对抗最强的，他们的后卫每场比赛动不动就跑个8千1万的，而这8千1万真心不是慢慢悠悠颠儿下来的，而是各种加速减速变向拼抢，所以其强度非常之大。那么这就需要很好的心肺系统功能，一方面体现在有氧与无氧耐力上，另一方面呼吸器官的机能上。游泳练习，不仅可以提高有氧以及无氧耐力，其水环境还可以给胸扩张带来阻力，直接锻炼了呼吸肌的收缩能力。另外，水环境真的能够给人们带来愉悦的感觉，特别是水流水压给肌肉和筋膜的按摩效果，真的是一举两得的“功能性”训练。 还有，你以为篮球运动员的拳击练习真的只是给枯燥乏味的体能训练增加一点乐趣么？并不是！ 1. 拳击可以在发生场内冲突的时候很好地保护自己； 2. 拳击运动可以强化旋转动作模式下的速度、稳定、和准确性； 3. 拳击是手脚高度协调的运动，对于发展手脚搭配的动作灵敏有神奇的效果。 而这些不就是一名篮球运动员所需要的么？！ 总结所以，功能性原则，解决的是“为什么练（for！not why）以及 练什么”的问题！ 如果我们是简单活动活动身体那就算了，但如果我们要进行一个有针对性的体能训练，那么请琢磨琢磨你选择的动作是否合理，是否能够满足你的专项需求！ 所以，招财猫式弹力带抗阻外旋真的是练习肩袖首推的动作么？ 所以，蚌式练习和dirty dog真的是发展髋外旋外展能力最好的练习么？ 所以，仰卧卷腹发展出来的腹直肌是好看呢？还是好用呢？ 所以，我们真的要来一次大清洗，摒弃掉我们以前那些练习么？ 当然不要！每一个动作都有它存在的意义，都有它的价值所在！有可能这个动作和你要发展的能力不直接相关，但是它可能是你进行“功能性”训练的基础，你不得不去做它！ 所以，训练的逻辑很重要！ 转自《体能训练之功能性》]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>健身</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「体能训练理论」之动力链]]></title>
    <url>%2F%E6%97%A5%E5%B8%B8%2F2017-07-10-%E3%80%8C%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA%E3%80%8D%E4%B9%8B%E5%8A%A8%E5%8A%9B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[引言与其说体能训练是一种行为，不如说体能训练是一种程序。只要符合逻辑，就可以自由组合。 那么体能训练的逻辑是什么？我们将之总结为：动力链、功能性、金字塔。 动力链如果说 五大运动素质（力量、速度、耐力、灵敏、柔韧）代表了体能的宏观表现，那么动力链理论则阐释了人体解剖结构在运动中的客观规律，这二者同为人体的本质属性。 动力链这一理论早在1875年就被提出过，当时的定义还很简单，就是指几个相邻的关节所组成的复杂动作单元。后来在不断地实践与研究中，动力链理论也不断的升级，越来越清晰，越来越客观，也越来越复杂，并且逐渐成为了体能训练师们必备的思考工具之一。 来看看动力链的英文解释: The concept of the kinetic chain originated in 1875, when a mechanical engineer named Franz Reuleaux proposed that if a series of overlapping segments were connected via pin joints, these interlocking joints would create a system that would allow the movement of one joint to affect the movement of another joint within the kinetic link. Dr. Arthur Steindler adapted this theory in 1955, and included an analysis of human movement. Steindler suggested that the extremities be viewed as a series of rigid, overlapping segments and defined the kinetic chain as a “combination of several successively arranged joints constituting a complex motor unit.” The movements that occur within these segments present as two primary types—open and closed. 这种模糊形容根本无法让人们理解它真正的内核，虽然它看起来就像是一堆联动的齿轮和杠杆。实际上它也真的很像一堆齿轮和杠杆，有的负责驱动，有的负责传力，有的负责稳定。 为了方便大家理解，下面我要将这个理论拆解开来跟大家分享。 首先，我们需要从以上的定义中提炼出来一些关键词，比如说 “运动”、“几个”、“相邻”等等。那么这几个词分别代表了什么？ 我们讨论问题的角度是运动的； 我们需要考虑的人体解剖结构问题； 我们需要考虑相邻关节的协作关系； 我们需要分析每一个关节的使用特点。 所以，它似乎并不能被完美的定义，而是只可意会不可言传。 那么关于动力链，我们需要掌握两个最基本的知识：动力链模型、开链与闭链。 动力链模型在动力链理论中，我们考虑运动的最小单位是关节，诸多关节运动的协作产生了整体上的复杂动作。所以每一个关节的功能就决定了整体动作的表现，任何一个关节功能受限都会导致整体动作的失衡。 而我们所指的关节功能，可以从生物力学角度简单的概括为： 灵活(M,Mobility) 稳定(S,Stability) 但看起来简单的两个词，其实意义非常。 什么是灵活？ 很多人的第一反应就是能自由的运动呗~然后部分专业人士可能会想到活动度。但是你的关节如果仅仅具备很好的活动度就能够胜任运动中的需求么？显然是不能的。所以灵活的意义远不止关节活动度，关节活动度仅仅是灵活的基础，而更重要的还有产力的能力。没错，这里的灵活既包括关节主被动活动范围，也包括产力的能力，比如产力的大小，产力的快慢等等。 举个例子：小明的髋关节活动范围非常好，能竖叉能横叉，但是臀大肌并没有很好的力量，所以不能够支撑你的跑步与跳跃，所以此时的髋关节灵活性仍然是不足的，只不过这里强调的是力量的缺失。 什么是稳定？ 稳定就是稳定呗~就是待着不动呗~就是牢固呗~灵活还能说出个关节活动度，而稳定的定义真的让很多人摸不到头脑，因为似乎“稳定”一词已经很好地形容了关节的功能表现。但是实际上我们仍然可以对其进行深究，并且这样做是有意义的，因为表现的不同直接影响训练的手段。 如果我们把“稳定”定义为是一种提供安全性的保护，那么我们就可以假想出两个现象： 一个非常贵重的瓷器抱在手中，我不能把它摔碎，所以我抱着不动~ 同样是这个非常贵重的瓷器抱在手中，我不能把它摔碎，但是我可以慢慢的把它放在地上。同样是保护瓷器不被摔碎，但是却有两个表现，一个是hold住，另外一个是慢慢的放在地上，一个不动，一个动。所以我们人体关节的稳定也是如此，既包括保持身体姿态，关节位置的相对固定，也包括有控制的缓冲外力，退让做功。 举个例子：我们的核心区域在运动中应该尽可能的保持姿态的稳定，所以是抱着瓷器不动；我们的膝关节在走路与跑步中从伸到屈，缓冲脚落地产生的冲击力，所以是抱着瓷器往下放。 在了解了 SM (稳定和灵活)的意义之后，更重要的是明白：这两种并不会孤立的存在，而是相辅相成同时存在的，只不过在人体整体动力链中体现的侧重点不一样，在肢体的协同运动中扮演的角色不一样。比如对于核心区域来说，灵活恰是其稳定的基础，因为不同体位下脊柱的排列形式直接影响稳定的表现。 当 SM 代表了关节功能之后，在人体的整体运动结构中，不同的关节所凸显出来的功能是不同的，并且它们遵循一定的逻辑分布。 从下往上说： 足弓——稳定 第一个缓冲冲击力的关节，并且没有多大的关节活动度。 足踝——灵活 “足” “踝”形成了一个稳定与灵活兼备的整体，但是在运动中它是下肢蹬伸最后一个主动发力的关节，并且无时无刻不在调整着身体与地面之间的位置关系，所以在这里我们更强调它的灵活性。 膝关节——稳定 强大的承重关节，且仅存在屈伸的动作（屈膝位的内外旋的意义是提供可控的缓冲空间，并非叫你主动旋转），更重要的是，无论走路、跑步、跳跃，膝关节都是非常重要的离心缓冲关节。 髋关节——灵活 强大的发力关节，而且活动范围也非常广泛，它引领着下肢的动作产生。但是由于位置与功能的特殊，所以其稳定性也相当重要，直接可以影响核心的稳定结构，特别是在闭链状态下。 腰椎——稳定 相对的绝对稳定体。所谓绝对，是因为腰椎所处的位置恰好为核心地带，这里的功能是维持姿态以及为上下肢的运动提供稳定基础，所以要“抱着缸不动”。而所谓相对，是因为不同的体位下腰椎的姿态是需要随之调整的，并不能以不变应万变。 胸椎——灵活 胸椎的灵活性其实并不好，但是相比于腰椎来说就好太多了，特别是在旋转动作上。在旋转鞭打的动作模式中，胸椎是继下肢产力之后的第一个角速度放大的关节，其灵活程度直接影响了上肢的鞭打效果。当然，在更多的时候胸椎要参与承重，但即便承重，也是以其良好的灵活性为基础的，比如说手臂上举过头负重的动作。 颈椎——稳定 虽然很灵活，但却需要很稳定！因为头部的位置变化会直接改变身体肌张力的大小分布，这个不仅可以让我们身体姿态发生变化，还会破坏掉本体感觉的准确性。当然，这也是猫在空中可以转体的原因，以及为什么我们打拳的时候不能回头。 肩胛胸关节——稳定 这是一个很奇葩的关节，从动力链结构上看，它是稳定关节，但稳定的并不是它自己，而是肩关节。在实际运动中，肩胛胸关节和肩关节是联动运动的，而且前者为后者提供稳定性，是后者得以安全展现灵活的基础。但是这个“稳定”恰恰是通过肩胛胸关节本身的灵活性来展现的，比如手臂上举时的上回旋。 肩关节——灵活 没的说，人体最灵活的关节，也是人体最不稳定的关节，其球窝关节的解剖结构已经说明了一切。 肘关节——稳定 结构上跟膝关节相对，但是实际上要比膝关节灵活的多。所以如果进化论成立的话，人类从四脚着地变成双脚着地的过程，使我们的下肢关节趋向于稳定，上肢关节趋向于灵活。而这正与 “开链”或者“闭链”的需求相适应。 开链&amp;闭链我们的关节同时存在S与M，而在整体的运动中有不同的体现，甚至于同样是S或者M的上下肢关节却存在了显著的差别。那么在此我们需要引出一个新的概念：开链 &amp; 闭链。 开链 开链，简单地说就是我们身体产生力量，改变了外界物体的运动状态。比如说哑铃二头弯举，投掷，摘苹果等动作都是开链动作。我们可以认为我们的身体在对抗趋于无穷小的阻力，那么我们就可以随意改变物体的运动状态，随便摆弄它，所以此时我们的肢体的灵活性就可以充分的发挥。比如我们的上肢就是以开链运动为主的，所以它整体表现出更好的灵活性。 闭链 闭链，简单的说就是我们的身体产生力量，却没能推动外界的物体，反而改变了我们自身的运动状态。比如说跑步与深蹲，我们扒地，我们蹬地，并没有让地板产生位移，我们自己却向前或者向上运动了。所以我们可以认为闭链运动时，我们的身体在对抗趋于无穷大的阻力，我们根本不可能改变它，所以只能运动我们自己。而在面对这样无穷大的阻力的时候，我们需要将我们的关节摆在力学结构最优的位置上才能发挥我们自身的最大经济性和效率，而且在这个状态下，各个关节的位置直接影响了身体的整体姿态和状态，所以灵活性被抑制。我们的下肢，最擅长、做的最多的就是闭链运动，所以它更加的趋于稳定。 开链和闭链直接影响我们的训练适应，因为它们所表现的力学结构是不同的。 总结了解动力链并不是让我们装逼的，而是让我们更加了解人体的客观规律来指导训练的。 它是一个非常好的思考工具。比如我们在训练下肢力量的时候，我们就需要考虑髋关节灵活性对于下肢力量表现的影响，于是乎我们可能更加重点强化髋的产力能力。但是当考虑到屈髋动作时，也许实际中更多的是开链的屈髋，所以我们就能以此为依据来选择髂腰肌和股直肌的训练动作。 除此之外，每个关节本身的功能完整性是非常重要的，如果一个关节有功能缺陷，那么在整体运动中它就不能够尽到它的职责，所以一定会有另外一个或者几个关节来代偿它的功能，那么就相当于一个3人的团队，一个请假了，另外两个就得加班。如果一次两次没关系，它要是请了一年的产假，那么另外俩人可能会由于长期超负荷工作而积劳成疾。当然，对于公司来说我可以再雇人，但是我们的人体可没有能再多长一个关节之说。 所以其实很多跑步膝的问题恰是由于髋和踝的功能缺陷而导致的。 最后我要再次强调：任何一个关节，稳定与灵活同时存在，只不过体现的程度和侧重不同。在动力链中，灵活的关节不代表没有稳定，更不代表稳定不重要；稳定的关节也需要灵活，而且灵活可能是稳定的基础。 了解了动力链，你会更懂运动中的人体，也许你有了思考问题的方向，但仍然缺少方法，所以你还需要具备「功能性」的思维方式。 转自 《体能训练之动力链》]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>健身</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「体能训练理论」之金字塔]]></title>
    <url>%2F%E6%97%A5%E5%B8%B8%2F2017-07-10-%E3%80%8C%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA%E3%80%8D%E4%B9%8B%E9%87%91%E5%AD%97%E5%A1%94%2F</url>
    <content type="text"><![CDATA[引言体能，人体基础运动能力的统称，人体的本质属性，它支撑着日常生活工作的需要，也支撑着运动技战术的表现。 体能思路，是指导我们设计实施体能训练的思维方式，分析逻辑。它包括回归原点的 五大运动素质 &amp; 动力链理论，也包括在过程中引领方向的 功能性原则 和 金字塔 。 金字塔体能训练是一门实践科学，实践先于理论，而理论印证实践。体能训练有四大基础学科，分别是运动解剖学、运动生理学、运动生物力学和运动训练学。 五大运动素质对应生理学和运动训练学；动力链对应解剖学和运动生物力学；功能性对应着生理和生物力。而金字塔则对应了它们全部！或者说金字塔其实是诸学科在体能训练中的交汇，它囊括了所有之前的理论，并且赋予了更深层的意义。 金字塔代表了人体运动能力发展的客观规律，它是一个流程的引领，思维的分级，以及训练阶段的划分。 这里包括 关节功能+核心控制、基础动作模式、基础力量、综合体能、专项运动。他们在逻辑上互为基础和进阶，关节是动作的基础，动作承载力量，力量支撑各个运动素质，而专项是各个运动素质在具体运动中的表现。 也许这么说可能不能够让大家有清晰的认识，那么接下来我就把每层的内容和它们之间的逻辑关系简单的跟大家分享一下。 99%的运动者都是基础不足，上层过度。我们从基础开始，从下往上说起。 运动基础（关节功能 + 核心控制）运动基础主要内容包括 关节功能 和 核心控制 能力。 人体的关节功能有两个属性，一个是灵活性，一个是稳定性。举例来说，很多人由于长期缺乏锻炼，肩关节灵活性缺失，第一次学习竖直上举时，怎么努力都举不到头顶，显然应该先改善肩关节灵活性。再比如，膝关节的结构导致它只能进行屈伸的运动，所以我们要保证运动过程中不出现膝内扣，膝外翻的现象，也就是膝关节需要具备的稳定能力。在健身之前我们，应该先评估我们的关节功能。 运动基础中的第二部分内容就是核心控制能力。很多健身者入门者都会觉得核心是腹肌，觉得练核心的目的是拥有一个好看的腹肌。实际上，腹肌只是核心的一部分，核心是指一个区域，我们的整个躯干都属于核心区域。 运动的外在表现虽来源于四肢，比如跑步时你的四肢在运动，但是一个出色的外在运动表现是建立在稳定的核心基础之上的。如果躯干不稳定，在跑步的过程中整个脊柱很松散，甩来甩去，这样是很难提高跑步速度的。所以在学习动作之前，应该先加强核心控制能力。 所以我们会推荐没有进行过抗阻训练、长期久坐的同学先去练习一段时间的瑜伽和普拉提，瑜伽可以很好地改善关节灵活性，进而提高身体的柔韧性；而普拉提能提高的核心控制能力，并提高关节稳定性。一个合格的健身训练者，应该了解不同的训练体系，他要知道自身还缺乏什么，然后向不同的训练体系去借鉴，以提高自己。 基础动作模式什么是基础动作模式？简单地说就是，所有动作肢体特有的运动程序。人体就这么些零件，所以很多的动作之间都存在着些许的共性，我们将这些共性提炼出来并进行功能上的抽象，那么就形成了我们现在所要说的基础动作模式——双腿蹲、单腿蹲、推、拉、旋转、屈髋。 蹲：分为单腿蹲、双腿蹲。对应的训练动作有剪蹲和深蹲。 推：分为水平推、竖直推。对应的训练动作是卧推和实力举。 拉：分为竖直拉、水平拉。竖直拉包括引体向上、高位下拉，水平拉包括弹力带划船等等。 屈髋：最具代表性的动作就是硬拉。 旋转：动作比较复杂，在训练当中比较少出现，适合比较资深的训练者，比如说劈和砍，比如下劈球，比如拿锤子砸轮胎。前期不建议做，当你有一定训练水平的时候再去做旋转类动作。 基础动作模式的意义是什么？ 教会我们如何正确的使用我们的身体 评估你的是否存在关节功能缺陷 基于基础动作模式的学习意义和诊断意义，我们对待健身者或者需要进行体能训练的人很多时候都从这里开始。如果诊断结果良好，那么我们学习动作之后就可以上升到基础力量训练，如果诊断出关节功能缺陷，我们就要进行针对性的解决。 基础力量（肌肉力量）力量是所有运动素质的基础，如果你没有足够的力量，很多事情都很难完成。你想学习倒立，如果上肢力量足够，只需要了解动作技巧和细节，可能半个小时就能学会倒立。但是如果力量水平很低，就算把各种技巧和细节都学会了，也没有力气把自身撑起来，更不可能完成倒立。日常生活中，力量水平不足经常会成为我们突破运动瓶颈的障碍，有足够的力量才能跑得更快、跑得更远、跳得更高。所以，力量是所有运动素质的基础。 因此，在金字塔的这层，我们就要从徒手训练的阶段进阶到自由力量训练的阶段。负重和徒手的训练效果差异非常大，它不仅仅在于力量的提高，在重心控制、身体平衡、协调性控制等方面的区别也很大。力量训练能让身体各项能力同时提高，只有真正进入力量训练阶段（对于健身来说），才可以说真正踏上健身入门之路。 训练目标（综合体能和专项体能）最后，我们来到了金字塔的顶端，这就是我们的最终追求。 综合体能在此指的是体能所包含的五大运动素质——力量，速度，灵敏，耐力，柔韧。对于有专项运动需求的人，我们需要有针对性的重点发展这五大运功素质中的某几个。 当我们身体各关节灵活性和稳定性都可以满足要求，且核心控制能力也很强的情况下，又在标准动作的基础上储备了足够的肌肉力量，那么，不管你的目标是减肥，增肌，或者是进行某一个竞技性运动项目，你都可以相对安全且轻松地达成你的目标。 一般我们把还处在第一第二层的健身者称为健身入门者。不管你是刚刚走进健身房的新手，还是健身多年的老司机，都可以根据这个健身发展流程来审视自己目前的训练处在哪一个阶段。 总结体能训练金字塔告诉我们，体能训练要从关节功能和核心控制开始训练，通过六大基础运动模式的训练增强身体基础力量，只有基础力量够了，我们才能真正开始我们的训练目标，根据我们训练的项目增强专项体能，比如拳击，我们要增强力量，耐力，灵敏。 清楚了这个体能训练金字塔之后，更重要的事还是要去执行。执行层面会涉及更多技术问题，也就是我们常说的如何做标准的动作，如何制定适合自己的训练计划等等。 健身是一项系统性工程，愿每一个人都能找到方法，科学有效地塑造自己的身体。 参考 《体能训练之金字塔》 零基础健身者的运动发展流程]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>健身</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode9 无线调试功能]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2017-07-04-Xcode9-%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[支持：Xcode 9 及 iOS 11 使用数据线连接 iPhone 到电 Mac，Mac 和 iPhone 必须在同一个局域网 1. 打开设备列表使用快捷键盘 ⇧⌘2或 在 Xcode 菜单栏选择 Window &gt; Devices and Simulators,打开设备列表 2. 勾选在线调试按钮 3. 拔掉数据线这时就可以无线调试了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速配置zsh]]></title>
    <url>%2Funcategorized%2F2017-06-19-%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AEzsh%2F</url>
    <content type="text"><![CDATA[比较水的 Personal Notes 查看你的系统有几种shellcat /etc/shells 显示 /bin/bash /bin/csh /bin/ksh /bin/sh /bin/tcsh /bin/zsh 安装 oh my zshgit clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 重新打开终端，输入 zsh 即可切换终端，并且发现 oh my zsh 已经帮我们配置好 zsh 了 修改主题open ~/.zshrc 修改 ZSH_THEME=”robbyrussell”，主题在 ~/.oh-my-zsh/themes 目录下。修改为 ZSH_THEME=&quot;kolo&quot; 可以参照这里进行选择. 设置为默认shellchsh -s /bin/zsh 添加自定义命令open ~/.zshrc 添加显示隐藏文件的快捷命令 alias fd=&#39;defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder&#39; alias fh=&#39;defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder&#39;]]></content>
      <tags>
        <tag>终端</tag>
        <tag>zsh</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Swift 中使用 IBInspectable]]></title>
    <url>%2Funcategorized%2F2017-05-05-%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8-IBInspectable%2F</url>
    <content type="text"><![CDATA[本文首次发布于 BY Blog, 作者 @柏荧(BY) ,转载请保留原文链接. 前言通过 IB 设置 控件 的属性非常的方便。 但是缺点也很明显，那就是有一些属性没有暴露在 IB 的设置面板中。这时候就要使用 @IBInspectable 在 IB 面板中添加这些没有的属性。 关于在 OC 中使用 IBInspectable 可以看一下我的 这篇文章 正文在项目中最常遇到的情况是为 view 设置圆角、描边，以及为 文本控件 添加本地化字符串。 圆角、描边先来看看设置圆角、描边 12345678910111213141516171819202122232425262728293031extension UIView &#123; @IBInspectable var cornerRadius: CGFloat &#123; get &#123; return layer.cornerRadius &#125; set &#123; layer.cornerRadius = newValue layer.masksToBounds = newValue &gt; 0 &#125; &#125; @IBInspectable var borderWidth: CGFloat &#123; get &#123; return layer.borderWidth &#125; set &#123; layer.borderWidth = newValue &gt; 0 ? newValue : 0 &#125; &#125; @IBInspectable var borderColor: UIColor &#123; get &#123; return UIColor(cgColor: layer.borderColor!) &#125; set &#123; layer.borderColor = newValue.cgColor &#125; &#125; &#125; 添加完成就可以在 IB 中设置 view 的这些属性了 运行效果 利用 @IBDesignable 在 IB 中实时显示 @IBInspectable 的样式创建一个新的 class 继承 UIView ，并且使用 @IBDesignable 声明 12345import UIKit@IBDesignable class IBDesignableView: UIView &#123;&#125; 在 IB 中，选择 view 的 class 为 我们新建的 IBDesignableView 这样在 IB 调整属性时，这些属性的变化就会实时显示在 IB 中。 本地化字符串本地化字符串的解决方法和上面的添加圆角一样 1234567891011121314151617181920212223242526272829extension UILabel &#123; @IBInspectable var localizedKey: String? &#123; set &#123; guard let newValue = newValue else &#123; return &#125; text = NSLocalizedString(newValue, comment: "") &#125; get &#123; return text &#125; &#125;&#125;extension UIButton &#123; @IBInspectable var localizedKey: String? &#123; set &#123; guard let newValue = newValue else &#123; return &#125; setTitle(NSLocalizedString(newValue, comment: ""), for: .normal) &#125; get &#123; return titleLabel?.text &#125; &#125;&#125;extension UITextField &#123; @IBInspectable var localizedKey: String? &#123; set &#123; guard let newValue = newValue else &#123; return &#125; placeholder = NSLocalizedString(newValue, comment: "") &#125; get &#123; return placeholder &#125; &#125;&#125; 这样，在 IB 中我们就可以利用对应类型的 Localized Key 来直接设置本地化字符串了： 结语IBInspectable 可以使用这些的类型 Int CGFloat Double String Bool CGPoint CGSize CGRect UIColor UIImage 合理的使用@IBInspectable 能减少很多的模板代码，提高我们的开发效率。 参考 《再看关于 Storyboard 的一些争论》 《@IBDesignable and @IBInspectable in Swift 3》]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>IBInspectable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R.swift 的使用]]></title>
    <url>%2Funcategorized%2F2017-05-04-R.swift-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文首次发布于 BY Blog, 作者 @柏荧(BY) ,转载请保留原文链接. 什么是 R.swift介绍 R.swift 前，我们先看看 R.swift 能做什么 通常，我们是基于 字符串 来获取资源，例如：图片、xib、或者是 segue 12let myImage = UIImage(named: "myImage")let myViewController = R.storyboard.main.myViewController() 使用 R.swfit，我们可以这样写 12let myImage = R.image.myImage()let viewController = R.storyboard.main.myViewController() R.swift 通过扫描你的各种基于字符串命名的资源，创建一个使用类型来获取资源。 在保证类型安全的同时，也在自动补全的帮助下节省了大量的时间。 导入 R.swiftR.swift 开源在 github 上。 这里是导入的视频教程 使用 CocoaPods 导入项目中 添加 pod &#39;R.swift&#39;到 Podfile 文件，然后运行 pod install 添加一个 New Run Script Phase 将 Run Script 拖动到 Check Pods Manifest.lock 的下面，并且添加脚本 &quot;$PODS_ROOT/R.swift/rswift&quot; &quot;$SRCROOT/项目名称&quot; Command+B 编译项目，在项目代码目录下，会生成一个 R.generated.swift 的文件，将它拖如项目中 注意：不要勾选 Copy items if needed 选项，因为每次编译都会生成新的 R.generated.swift 文件，copy 的话，旧的 R.generated.swift 将不会被覆盖。 tip： 可以在添加 .gitignore 添加一行 *.generated.swift 忽略该文件，避免造成冲突 用法导入完成后，就可以在使用 R.swift 了 关于 R.swift 的更多用法，可以 看这里。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 的懒加载和计算型属性]]></title>
    <url>%2Funcategorized%2F2017-05-03-Swift-%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E5%9E%8B%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[本文首次发布于 BY Blog, 作者 @柏荧(BY) ,转载请保留原文链接. 懒加载常规（简化）写法 懒加载的属性用 var 声明 123lazy var name: String = &#123; return &quot;BY&quot;&#125;() 完整写法 123lazy var name: String = &#123; () -&gt; String i return &quot;BY&quot;&#125;() 本质是一个创建一个闭包 {} 并且在调用该属性时执行闭包 ()。 如OC的懒加载不同的是 swift 懒加载闭包只调用一次，再次调用该属性时因为属性已经创建，不再执行闭包。 计算型属性常规写法 123var name: string &#123; return &quot;BY&quot;&#125; 完整写法 12345var name: string &#123; get &#123; return &quot;BY&quot; &#125;&#125; 计算型属性本质是重写了 get 方法，其类似一个无参有返回值函数，每次调用该属性都会执行 return 通常这样使用 123456789struct Cuboid &#123; var width = 0.0, height = 0.0, depth = 0.0 var volume: Double &#123; return width * height * depth &#125;&#125;let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)print(&quot;the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)&quot;)// Prints &quot;the volume of fourByFiveByTwo is 40.0&quot; 两者对比相同点 使用方法完全一致 都是用 var 声明 不同点 实现原理不同 懒加载是第一次调用属性时执行闭包进行赋值 计算型属性是重写 get 方法 调用 {}的次数不同 懒加载的闭包只在属性第一次调用时执行 计算型属性每次调用都要进入 {} 中，return 新的值]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Swift语法</tag>
      </tags>
  </entry>
</search>
